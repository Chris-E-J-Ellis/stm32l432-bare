// this file was generated by regz: https://github.com/ZigEmbeddedGroup/regz
// commit: 341b0177d90a56f4307cc3226d552b39b048e7fa
//
// device: STM32L4x2
// cpu: CM4

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    MemManage: InterruptVector = unhandled,
    BusFault: InterruptVector = unhandled,
    UsageFault: InterruptVector = unhandled,
    reserved0: [4]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    /// Window Watchdog interrupt
    WWDG: InterruptVector = unhandled,
    /// PVD through EXTI line detection
    PVD_PVM: InterruptVector = unhandled,
    /// Tamper and TimeStamp interrupts
    RTC_TAMP_STAMP: InterruptVector = unhandled,
    /// RTC Tamper or TimeStamp /CSS on LSE through
    /// EXTI line 19 interrupts
    RTC_WKUP: InterruptVector = unhandled,
    /// Flash global interrupt
    FLASH: InterruptVector = unhandled,
    /// RCC global interrupt
    RCC: InterruptVector = unhandled,
    /// EXTI Line 0 interrupt
    EXTI0: InterruptVector = unhandled,
    /// EXTI Line 1 interrupt
    EXTI1: InterruptVector = unhandled,
    /// EXTI Line 2 interrupt
    EXTI2: InterruptVector = unhandled,
    /// EXTI Line 3 interrupt
    EXTI3: InterruptVector = unhandled,
    /// EXTI Line4 interrupt
    EXTI4: InterruptVector = unhandled,
    /// DMA1 Channel1 global interrupt
    DMA1_CH1: InterruptVector = unhandled,
    /// DMA1 Channel2 global interrupt
    DMA1_CH2: InterruptVector = unhandled,
    /// DMA1 Channel3 interrupt
    DMA1_CH3: InterruptVector = unhandled,
    /// DMA1 Channel4 interrupt
    DMA1_CH4: InterruptVector = unhandled,
    /// DMA1 Channel5 interrupt
    DMA1_CH5: InterruptVector = unhandled,
    /// DMA1 Channel6 interrupt
    DMA1_CH6: InterruptVector = unhandled,
    /// DMA1 Channel 7 interrupt
    DMA1_CH7: InterruptVector = unhandled,
    /// ADC1 and ADC2 global interrupt
    ADC1: InterruptVector = unhandled,
    /// CAN1 TX interrupts
    CAN1_TX: InterruptVector = unhandled,
    /// CAN1 RX0 interrupts
    CAN1_RX0: InterruptVector = unhandled,
    /// CAN1 RX1 interrupts
    CAN1_RX1: InterruptVector = unhandled,
    /// CAN1 SCE interrupt
    CAN1_SCE: InterruptVector = unhandled,
    /// EXTI Line5 to Line9 interrupts
    EXTI9_5: InterruptVector = unhandled,
    /// Timer 15 global interrupt
    TIM1_BRK_TIM15: InterruptVector = unhandled,
    /// Timer 16 global interrupt
    TIM1_UP_TIM16: InterruptVector = unhandled,
    /// TIM1 trigger and commutation
    /// interrupt
    TIM1_TRG_COM: InterruptVector = unhandled,
    /// TIM1 Capture Compare interrupt
    TIM1_CC: InterruptVector = unhandled,
    /// TIM2 global interrupt
    TIM2: InterruptVector = unhandled,
    /// TIM3 global interrupt
    TIM3: InterruptVector = unhandled,
    reserved2: u32 = undefined,
    /// I2C1 event interrupt
    I2C1_EV: InterruptVector = unhandled,
    /// I2C1 error interrupt
    I2C1_ER: InterruptVector = unhandled,
    /// I2C2 event interrupt
    I2C2_EV: InterruptVector = unhandled,
    /// I2C2 error interrupt
    I2C2_ER: InterruptVector = unhandled,
    /// SPI1 global interrupt
    SPI1: InterruptVector = unhandled,
    /// SPI2 global interrupt
    SPI2: InterruptVector = unhandled,
    /// USART1 global interrupt
    USART1: InterruptVector = unhandled,
    /// USART2 global interrupt
    USART2: InterruptVector = unhandled,
    /// USART3 global interrupt
    USART3: InterruptVector = unhandled,
    /// EXTI Lines 10 to 15 interrupts
    EXTI15_10: InterruptVector = unhandled,
    /// RTC alarms through EXTI line 18
    /// interrupts
    RTC_ALARM: InterruptVector = unhandled,
    /// DFSDM1_FLT3 global interrupt
    DFSDM1_FLT3: InterruptVector = unhandled,
    reserved3: u32 = undefined,
    reserved4: u32 = undefined,
    reserved5: u32 = undefined,
    reserved6: u32 = undefined,
    /// ADC3 global Interrupt
    ADC3: InterruptVector = unhandled,
    reserved7: u32 = undefined,
    /// SDMMC global Interrupt
    SDMMC1: InterruptVector = unhandled,
    reserved8: u32 = undefined,
    /// SPI3 global Interrupt
    SPI3: InterruptVector = unhandled,
    /// UART4 global Interrupt
    UART4: InterruptVector = unhandled,
    reserved9: u32 = undefined,
    /// TIM6 global and DAC1 and 2 underrun error
    /// interrupts
    TIM6_DACUNDER: InterruptVector = unhandled,
    /// TIM7 global interrupt
    TIM7: InterruptVector = unhandled,
    /// DMA2 Channel 1 global Interrupt
    DMA2_CH1: InterruptVector = unhandled,
    /// DMA2 Channel 2 global Interrupt
    DMA2_CH2: InterruptVector = unhandled,
    /// DMA2 Channel 3 global Interrupt
    DMA2_CH3: InterruptVector = unhandled,
    /// DMA2 Channel 4 global Interrupt
    DMA2_CH4: InterruptVector = unhandled,
    /// DMA2 Channel 5 global Interrupt
    DMA2_CH5: InterruptVector = unhandled,
    /// DFSDM1_FLT0 global interrupt
    DFSDM1_FLT0: InterruptVector = unhandled,
    /// DFSDM1_FLT1 global interrupt
    DFSDM1_FLT1: InterruptVector = unhandled,
    /// DFSDM1_FLT2 global interrupt
    DFSDM1_FLT2: InterruptVector = unhandled,
    /// COMP1 and COMP2 interrupts
    COMP: InterruptVector = unhandled,
    /// LP TIM1 interrupt
    LPTIM1: InterruptVector = unhandled,
    /// LP TIM2 interrupt
    LPTIM2: InterruptVector = unhandled,
    /// USB event interrupt through EXTI
    USB_FS: InterruptVector = unhandled,
    /// DMA2 Channel 6 global Interrupt
    DMA2_CH6: InterruptVector = unhandled,
    /// DMA2 Channel 7 global Interrupt
    DMA2_CH7: InterruptVector = unhandled,
    /// LPUART1 global interrupt
    LPUART1: InterruptVector = unhandled,
    /// Quad SPI global interrupt
    QUADSPI: InterruptVector = unhandled,
    /// I2C3 event interrupt
    I2C3_EV: InterruptVector = unhandled,
    /// I2C3 error interrupt
    I2C3_ER: InterruptVector = unhandled,
    /// SAI1 global interrupt
    SAI1: InterruptVector = unhandled,
    reserved10: u32 = undefined,
    /// SWPMI1 global interrupt
    SWPMI1: InterruptVector = unhandled,
    /// TSC global interrupt
    TSC: InterruptVector = unhandled,
    /// LCD global interrupt
    LCD: InterruptVector = unhandled,
    /// AES global interrupt
    AES: InterruptVector = unhandled,
    /// RNG global interrupt
    RNG: InterruptVector = unhandled,
    /// Floating point interrupt
    FPU: InterruptVector = unhandled,
    /// CRS interrupt
    CRS: InterruptVector = unhandled,
    /// I2C4 event interrupt, wakeup through
    /// EXTI
    I2C4_EV: InterruptVector = unhandled,
    /// I2C4 error interrupt
    I2C4_ER: InterruptVector = unhandled,
};

pub const registers = struct {
    /// System Control Space
    pub const SCS = struct {
        pub const base_address = 0xe000e000;

        /// System Tick Timer
        pub const SysTick = struct {
            /// address: 0xe000e010
            /// SysTick Control and Status Register
            pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                ENABLE: u1,
                TICKINT: u1,
                CLKSOURCE: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                COUNTFLAG: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x10);

            /// address: 0xe000e014
            /// SysTick Reload Value Register
            pub const LOAD = @intToPtr(*volatile Mmio(32, packed struct {
                RELOAD: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x14);

            /// address: 0xe000e018
            /// SysTick Current Value Register
            pub const VAL = @intToPtr(*volatile Mmio(32, packed struct {
                CURRENT: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x18);

            /// address: 0xe000e01c
            /// SysTick Calibration Register
            pub const CALIB = @intToPtr(*volatile Mmio(32, packed struct {
                TENMS: u24,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                SKEW: u1,
                NOREF: u1,
            }), base_address + 0x1c);
        };
    };

    /// Digital-to-analog converter
    pub const DAC1 = struct {
        pub const base_address = 0x40007400;

        /// address: 0x40007400
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 enable
            EN1: u1,
            reserved0: u1,
            /// DAC channel1 trigger
            /// enable
            TEN1: u1,
            /// DAC channel1 trigger
            /// selection
            TSEL1: u3,
            /// DAC channel1 noise/triangle wave
            /// generation enable
            WAVE1: u2,
            /// DAC channel1 mask/amplitude
            /// selector
            MAMP1: u4,
            /// DAC channel1 DMA enable
            DMAEN1: u1,
            /// DAC channel1 DMA Underrun Interrupt
            /// enable
            DMAUDRIE1: u1,
            /// DAC Channel 1 calibration
            /// enable
            CEN1: u1,
            reserved1: u1,
            /// DAC channel2 enable
            EN2: u1,
            reserved2: u1,
            /// DAC channel2 trigger
            /// enable
            TEN2: u1,
            /// DAC channel2 trigger
            /// selection
            TSEL2: u3,
            /// DAC channel2 noise/triangle wave
            /// generation enable
            WAVE2: u2,
            /// DAC channel2 mask/amplitude
            /// selector
            MAMP2: u4,
            /// DAC channel2 DMA enable
            DMAEN2: u1,
            /// DAC channel2 DMA underrun interrupt
            /// enable
            DMAUDRIE2: u1,
            /// DAC Channel 2 calibration
            /// enable
            CEN2: u1,
            padding0: u1,
        }), base_address + 0x0);

        /// address: 0x40007404
        /// software trigger register
        pub const SWTRIGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 software
            /// trigger
            SWTRIG1: u1,
            /// DAC channel2 software
            /// trigger
            SWTRIG2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x40007408
        /// channel1 12-bit right-aligned data holding
        /// register
        pub const DHR12R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 12-bit right-aligned
            /// data
            DACC1DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000740c
        /// channel1 12-bit left-aligned data holding
        /// register
        pub const DHR12L1 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel1 12-bit left-aligned
            /// data
            DACC1DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40007410
        /// channel1 8-bit right-aligned data holding
        /// register
        pub const DHR8R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 8-bit right-aligned
            /// data
            DACC1DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x40007414
        /// channel2 12-bit right aligned data holding
        /// register
        pub const DHR12R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 12-bit right-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x14);

        /// address: 0x40007418
        /// channel2 12-bit left aligned data holding
        /// register
        pub const DHR12L2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel2 12-bit left-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000741c
        /// channel2 8-bit right-aligned data holding
        /// register
        pub const DHR8R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 8-bit right-aligned
            /// data
            DACC2DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x40007420
        /// Dual DAC 12-bit right-aligned data holding
        /// register
        pub const DHR12RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 12-bit right-aligned
            /// data
            DACC1DHR: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel2 12-bit right-aligned
            /// data
            DACC2DHR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x40007424
        /// DUAL DAC 12-bit left aligned data holding
        /// register
        pub const DHR12LD = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DAC channel1 12-bit left-aligned
            /// data
            DACC1DHR: u12,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// DAC channel2 12-bit left-aligned
            /// data
            DACC2DHR: u12,
        }), base_address + 0x24);

        /// address: 0x40007428
        /// DUAL DAC 8-bit right aligned data holding
        /// register
        pub const DHR8RD = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 8-bit right-aligned
            /// data
            DACC1DHR: u8,
            /// DAC channel2 8-bit right-aligned
            /// data
            DACC2DHR: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000742c
        /// channel1 data output register
        pub const DOR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel1 data output
            DACC1DOR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x40007430
        /// channel2 data output register
        pub const DOR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC channel2 data output
            DACC2DOR: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x30);

        /// address: 0x40007434
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// DAC channel1 DMA underrun
            /// flag
            DMAUDR1: u1,
            /// DAC Channel 1 calibration offset
            /// status
            CAL_FLAG1: u1,
            /// DAC Channel 1 busy writing sample time
            /// flag
            BWST1: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            /// DAC channel2 DMA underrun
            /// flag
            DMAUDR2: u1,
            /// DAC Channel 2 calibration offset
            /// status
            CAL_FLAG2: u1,
            /// DAC Channel 2 busy writing sample time
            /// flag
            BWST2: u1,
        }), base_address + 0x34);

        /// address: 0x40007438
        /// calibration control register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC Channel 1 offset trimming
            /// value
            OTRIM1: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// DAC Channel 2 offset trimming
            /// value
            OTRIM2: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x38);

        /// address: 0x4000743c
        /// mode control register
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC Channel 1 mode
            MODE1: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// DAC Channel 2 mode
            MODE2: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x3c);

        /// address: 0x40007440
        /// Sample and Hold sample time register
        /// 1
        pub const SHSR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC Channel 1 sample Time
            TSAMPLE1: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x40);

        /// address: 0x40007444
        /// Sample and Hold sample time register
        /// 2
        pub const SHSR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC Channel 2 sample Time
            TSAMPLE2: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x44);

        /// address: 0x40007448
        /// Sample and Hold hold time
        /// register
        pub const SHHR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC Channel 1 hold Time
            THOLD1: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// DAC Channel 2 hold time
            THOLD2: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x48);

        /// address: 0x4000744c
        /// Sample and Hold refresh time
        /// register
        pub const SHRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DAC Channel 1 refresh Time
            TREFRESH1: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// DAC Channel 2 refresh Time
            TREFRESH2: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4c);
    };

    /// Direct memory access controller
    pub const DMA1 = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// interrupt status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF1: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF1: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF1: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF1: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF2: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF2: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF2: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF2: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF3: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF3: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF3: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF3: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF4: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF4: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF4: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF4: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF5: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF5: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF5: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF5: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF6: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF6: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF6: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF6: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF7: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF7: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF7: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40020004
        /// interrupt flag clear register
        pub const IFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF1: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF1: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF1: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF1: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF2: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF2: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF2: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF2: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF3: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF3: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF3: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF3: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF4: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF4: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF4: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF4: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF5: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF5: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF5: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF5: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF6: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF6: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF6: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF6: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF7: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF7: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF7: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40020008
        /// channel x configuration
        /// register
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4002000c
        /// channel x number of data
        /// register
        pub const CNDTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40020010
        /// channel x peripheral address
        /// register
        pub const CPAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x10);

        /// address: 0x40020014
        /// channel x memory address
        /// register
        pub const CMAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x14);

        /// address: 0x4002001c
        /// channel x configuration
        /// register
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40020020
        /// channel x number of data
        /// register
        pub const CNDTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40020024
        /// channel x peripheral address
        /// register
        pub const CPAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x24);

        /// address: 0x40020028
        /// channel x memory address
        /// register
        pub const CMAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x28);

        /// address: 0x40020030
        /// channel x configuration
        /// register
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x40020034
        /// channel x number of data
        /// register
        pub const CNDTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40020038
        /// channel x peripheral address
        /// register
        pub const CPAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x38);

        /// address: 0x4002003c
        /// channel x memory address
        /// register
        pub const CMAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x3c);

        /// address: 0x40020044
        /// channel x configuration
        /// register
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x44);

        /// address: 0x40020048
        /// channel x number of data
        /// register
        pub const CNDTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002004c
        /// channel x peripheral address
        /// register
        pub const CPAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x4c);

        /// address: 0x40020050
        /// channel x memory address
        /// register
        pub const CMAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x50);

        /// address: 0x40020058
        /// channel x configuration
        /// register
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x58);

        /// address: 0x4002005c
        /// channel x number of data
        /// register
        pub const CNDTR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40020060
        /// channel x peripheral address
        /// register
        pub const CPAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x60);

        /// address: 0x40020064
        /// channel x memory address
        /// register
        pub const CMAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x64);

        /// address: 0x4002006c
        /// channel x configuration
        /// register
        pub const CCR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x6c);

        /// address: 0x40020070
        /// channel x number of data
        /// register
        pub const CNDTR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x40020074
        /// channel x peripheral address
        /// register
        pub const CPAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x74);

        /// address: 0x40020078
        /// channel x memory address
        /// register
        pub const CMAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x78);

        /// address: 0x40020080
        /// channel x configuration
        /// register
        pub const CCR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x80);

        /// address: 0x40020084
        /// channel x number of data
        /// register
        pub const CNDTR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x40020088
        /// channel x peripheral address
        /// register
        pub const CPAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x88);

        /// address: 0x4002008c
        /// channel x memory address
        /// register
        pub const CMAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x8c);

        /// address: 0x400200a8
        /// channel selection register
        pub const CSELR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA channel 1 selection
            C1S: u4,
            /// DMA channel 2 selection
            C2S: u4,
            /// DMA channel 3 selection
            C3S: u4,
            /// DMA channel 4 selection
            C4S: u4,
            /// DMA channel 5 selection
            C5S: u4,
            /// DMA channel 6 selection
            C6S: u4,
            /// DMA channel 7 selection
            C7S: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xa8);
    };
    pub const DMA2 = struct {
        pub const base_address = 0x40020400;

        /// address: 0x40020400
        /// interrupt status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF1: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF1: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF1: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF1: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF2: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF2: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF2: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF2: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF3: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF3: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF3: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF3: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF4: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF4: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF4: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF4: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF5: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF5: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF5: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF5: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF6: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF6: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF6: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF6: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF7: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF7: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF7: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40020404
        /// interrupt flag clear register
        pub const IFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF1: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF1: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF1: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF1: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF2: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF2: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF2: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF2: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF3: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF3: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF3: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF3: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF4: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF4: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF4: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF4: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF5: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF5: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF5: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF5: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF6: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF6: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF6: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF6: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF7: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF7: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF7: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40020408
        /// channel x configuration
        /// register
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4002040c
        /// channel x number of data
        /// register
        pub const CNDTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40020410
        /// channel x peripheral address
        /// register
        pub const CPAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x10);

        /// address: 0x40020414
        /// channel x memory address
        /// register
        pub const CMAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x14);

        /// address: 0x4002041c
        /// channel x configuration
        /// register
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40020420
        /// channel x number of data
        /// register
        pub const CNDTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40020424
        /// channel x peripheral address
        /// register
        pub const CPAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x24);

        /// address: 0x40020428
        /// channel x memory address
        /// register
        pub const CMAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x28);

        /// address: 0x40020430
        /// channel x configuration
        /// register
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x40020434
        /// channel x number of data
        /// register
        pub const CNDTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40020438
        /// channel x peripheral address
        /// register
        pub const CPAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x38);

        /// address: 0x4002043c
        /// channel x memory address
        /// register
        pub const CMAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x3c);

        /// address: 0x40020444
        /// channel x configuration
        /// register
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x44);

        /// address: 0x40020448
        /// channel x number of data
        /// register
        pub const CNDTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002044c
        /// channel x peripheral address
        /// register
        pub const CPAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x4c);

        /// address: 0x40020450
        /// channel x memory address
        /// register
        pub const CMAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x50);

        /// address: 0x40020458
        /// channel x configuration
        /// register
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x58);

        /// address: 0x4002045c
        /// channel x number of data
        /// register
        pub const CNDTR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40020460
        /// channel x peripheral address
        /// register
        pub const CPAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x60);

        /// address: 0x40020464
        /// channel x memory address
        /// register
        pub const CMAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x64);

        /// address: 0x4002046c
        /// channel x configuration
        /// register
        pub const CCR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x6c);

        /// address: 0x40020470
        /// channel x number of data
        /// register
        pub const CNDTR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x40020474
        /// channel x peripheral address
        /// register
        pub const CPAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x74);

        /// address: 0x40020478
        /// channel x memory address
        /// register
        pub const CMAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x78);

        /// address: 0x40020480
        /// channel x configuration
        /// register
        pub const CCR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x80);

        /// address: 0x40020484
        /// channel x number of data
        /// register
        pub const CNDTR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x40020488
        /// channel x peripheral address
        /// register
        pub const CPAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x88);

        /// address: 0x4002048c
        /// channel x memory address
        /// register
        pub const CMAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x8c);

        /// address: 0x400204a8
        /// channel selection register
        pub const CSELR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA channel 1 selection
            C1S: u4,
            /// DMA channel 2 selection
            C2S: u4,
            /// DMA channel 3 selection
            C3S: u4,
            /// DMA channel 4 selection
            C4S: u4,
            /// DMA channel 5 selection
            C5S: u4,
            /// DMA channel 6 selection
            C6S: u4,
            /// DMA channel 7 selection
            C7S: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xa8);
    };

    /// Cyclic redundancy check calculation
    /// unit
    pub const CRC = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023000
        /// Data register
        pub const DR = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40023004
        /// Independent data register
        pub const IDR = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

        /// address: 0x40023008
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RESET bit
            RESET: u1,
            reserved0: u1,
            reserved1: u1,
            /// Polynomial size
            POLYSIZE: u2,
            /// Reverse input data
            REV_IN: u2,
            /// Reverse output data
            REV_OUT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x40023010
        /// Initial CRC value
        pub const INIT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programmable initial CRC
            /// value
            CRC_INIT: u32,
        }), base_address + 0x10);

        /// address: 0x40023014
        /// polynomial
        pub const POL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programmable polynomial
            Polynomialcoefficients: u32,
        }), base_address + 0x14);
    };

    /// Liquid crystal display controller
    pub const LCD = struct {
        pub const base_address = 0x40002400;

        /// address: 0x40002400
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LCD controller enable
            LCDEN: u1,
            /// Voltage source selection
            VSEL: u1,
            /// Duty selection
            DUTY: u3,
            /// Bias selector
            BIAS: u2,
            /// Mux segment enable
            MUX_SEG: u1,
            /// Voltage output buffer
            /// enable
            BUFEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);

        /// address: 0x40002404
        /// frame control register
        pub const FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// High drive enable
            HD: u1,
            /// Start of frame interrupt
            /// enable
            SOFIE: u1,
            reserved0: u1,
            /// Update display done interrupt
            /// enable
            UDDIE: u1,
            /// Pulse ON duration
            PON: u3,
            /// Dead time duration
            DEAD: u3,
            /// Contrast control
            CC: u3,
            /// Blink frequency selection
            BLINKF: u3,
            /// Blink mode selection
            BLINK: u2,
            /// DIV clock divider
            DIV: u4,
            /// PS 16-bit prescaler
            PS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x4);

        /// address: 0x40002408
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ENS
            ENS: u1,
            /// Start of frame flag
            SOF: u1,
            /// Update display request
            UDR: u1,
            /// Update Display Done
            UDD: u1,
            /// Ready flag
            RDY: u1,
            /// LCD Frame Control Register
            /// Synchronization flag
            FCRSF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x8);

        /// address: 0x4000240c
        /// clear register
        pub const CLR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Start of frame flag clear
            SOFC: u1,
            reserved1: u1,
            /// Update display done clear
            UDDC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xc);

        /// address: 0x40002414
        /// display memory
        pub const RAM_COM0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// S00
            S00: u1,
            /// S01
            S01: u1,
            /// S02
            S02: u1,
            /// S03
            S03: u1,
            /// S04
            S04: u1,
            /// S05
            S05: u1,
            /// S06
            S06: u1,
            /// S07
            S07: u1,
            /// S08
            S08: u1,
            /// S09
            S09: u1,
            /// S10
            S10: u1,
            /// S11
            S11: u1,
            /// S12
            S12: u1,
            /// S13
            S13: u1,
            /// S14
            S14: u1,
            /// S15
            S15: u1,
            /// S16
            S16: u1,
            /// S17
            S17: u1,
            /// S18
            S18: u1,
            /// S19
            S19: u1,
            /// S20
            S20: u1,
            /// S21
            S21: u1,
            /// S22
            S22: u1,
            /// S23
            S23: u1,
            /// S24
            S24: u1,
            /// S25
            S25: u1,
            /// S26
            S26: u1,
            /// S27
            S27: u1,
            /// S28
            S28: u1,
            /// S29
            S29: u1,
            /// S30
            S30: u1,
            padding0: u1,
        }), base_address + 0x14);

        /// address: 0x4000241c
        /// display memory
        pub const RAM_COM1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// S00
            S00: u1,
            /// S01
            S01: u1,
            /// S02
            S02: u1,
            /// S03
            S03: u1,
            /// S04
            S04: u1,
            /// S05
            S05: u1,
            /// S06
            S06: u1,
            /// S07
            S07: u1,
            /// S08
            S08: u1,
            /// S09
            S09: u1,
            /// S10
            S10: u1,
            /// S11
            S11: u1,
            /// S12
            S12: u1,
            /// S13
            S13: u1,
            /// S14
            S14: u1,
            /// S15
            S15: u1,
            /// S16
            S16: u1,
            /// S17
            S17: u1,
            /// S18
            S18: u1,
            /// S19
            S19: u1,
            /// S20
            S20: u1,
            /// S21
            S21: u1,
            /// S22
            S22: u1,
            /// S23
            S23: u1,
            /// S24
            S24: u1,
            /// S25
            S25: u1,
            /// S26
            S26: u1,
            /// S27
            S27: u1,
            /// S28
            S28: u1,
            /// S29
            S29: u1,
            /// S30
            S30: u1,
            /// S31
            S31: u1,
        }), base_address + 0x1c);

        /// address: 0x40002424
        /// display memory
        pub const RAM_COM2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// S00
            S00: u1,
            /// S01
            S01: u1,
            /// S02
            S02: u1,
            /// S03
            S03: u1,
            /// S04
            S04: u1,
            /// S05
            S05: u1,
            /// S06
            S06: u1,
            /// S07
            S07: u1,
            /// S08
            S08: u1,
            /// S09
            S09: u1,
            /// S10
            S10: u1,
            /// S11
            S11: u1,
            /// S12
            S12: u1,
            /// S13
            S13: u1,
            /// S14
            S14: u1,
            /// S15
            S15: u1,
            /// S16
            S16: u1,
            /// S17
            S17: u1,
            /// S18
            S18: u1,
            /// S19
            S19: u1,
            /// S20
            S20: u1,
            /// S21
            S21: u1,
            /// S22
            S22: u1,
            /// S23
            S23: u1,
            /// S24
            S24: u1,
            /// S25
            S25: u1,
            /// S26
            S26: u1,
            /// S27
            S27: u1,
            /// S28
            S28: u1,
            /// S29
            S29: u1,
            /// S30
            S30: u1,
            /// S31
            S31: u1,
        }), base_address + 0x24);

        /// address: 0x4000242c
        /// display memory
        pub const RAM_COM3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// S00
            S00: u1,
            /// S01
            S01: u1,
            /// S02
            S02: u1,
            /// S03
            S03: u1,
            /// S04
            S04: u1,
            /// S05
            S05: u1,
            /// S06
            S06: u1,
            /// S07
            S07: u1,
            /// S08
            S08: u1,
            /// S09
            S09: u1,
            /// S10
            S10: u1,
            /// S11
            S11: u1,
            /// S12
            S12: u1,
            /// S13
            S13: u1,
            /// S14
            S14: u1,
            /// S15
            S15: u1,
            /// S16
            S16: u1,
            /// S17
            S17: u1,
            /// S18
            S18: u1,
            /// S19
            S19: u1,
            /// S20
            S20: u1,
            /// S21
            S21: u1,
            /// S22
            S22: u1,
            /// S23
            S23: u1,
            /// S24
            S24: u1,
            /// S25
            S25: u1,
            /// S26
            S26: u1,
            /// S27
            S27: u1,
            /// S28
            S28: u1,
            /// S29
            S29: u1,
            /// S30
            S30: u1,
            /// S31
            S31: u1,
        }), base_address + 0x2c);

        /// address: 0x40002434
        /// display memory
        pub const RAM_COM4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// S00
            S00: u1,
            /// S01
            S01: u1,
            /// S02
            S02: u1,
            /// S03
            S03: u1,
            /// S04
            S04: u1,
            /// S05
            S05: u1,
            /// S06
            S06: u1,
            /// S07
            S07: u1,
            /// S08
            S08: u1,
            /// S09
            S09: u1,
            /// S10
            S10: u1,
            /// S11
            S11: u1,
            /// S12
            S12: u1,
            /// S13
            S13: u1,
            /// S14
            S14: u1,
            /// S15
            S15: u1,
            /// S16
            S16: u1,
            /// S17
            S17: u1,
            /// S18
            S18: u1,
            /// S19
            S19: u1,
            /// S20
            S20: u1,
            /// S21
            S21: u1,
            /// S22
            S22: u1,
            /// S23
            S23: u1,
            /// S24
            S24: u1,
            /// S25
            S25: u1,
            /// S26
            S26: u1,
            /// S27
            S27: u1,
            /// S28
            S28: u1,
            /// S29
            S29: u1,
            /// S30
            S30: u1,
            /// S31
            S31: u1,
        }), base_address + 0x34);

        /// address: 0x4000243c
        /// display memory
        pub const RAM_COM5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// S00
            S00: u1,
            /// S01
            S01: u1,
            /// S02
            S02: u1,
            /// S03
            S03: u1,
            /// S04
            S04: u1,
            /// S05
            S05: u1,
            /// S06
            S06: u1,
            /// S07
            S07: u1,
            /// S08
            S08: u1,
            /// S09
            S09: u1,
            /// S10
            S10: u1,
            /// S11
            S11: u1,
            /// S12
            S12: u1,
            /// S13
            S13: u1,
            /// S14
            S14: u1,
            /// S15
            S15: u1,
            /// S16
            S16: u1,
            /// S17
            S17: u1,
            /// S18
            S18: u1,
            /// S19
            S19: u1,
            /// S20
            S20: u1,
            /// S21
            S21: u1,
            /// S22
            S22: u1,
            /// S23
            S23: u1,
            /// S24
            S24: u1,
            /// S25
            S25: u1,
            /// S26
            S26: u1,
            /// S27
            S27: u1,
            /// S28
            S28: u1,
            /// S29
            S29: u1,
            /// S30
            S30: u1,
            /// S31
            S31: u1,
        }), base_address + 0x3c);

        /// address: 0x40002444
        /// display memory
        pub const RAM_COM6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// S00
            S00: u1,
            /// S01
            S01: u1,
            /// S02
            S02: u1,
            /// S03
            S03: u1,
            /// S04
            S04: u1,
            /// S05
            S05: u1,
            /// S06
            S06: u1,
            /// S07
            S07: u1,
            /// S08
            S08: u1,
            /// S09
            S09: u1,
            /// S10
            S10: u1,
            /// S11
            S11: u1,
            /// S12
            S12: u1,
            /// S13
            S13: u1,
            /// S14
            S14: u1,
            /// S15
            S15: u1,
            /// S16
            S16: u1,
            /// S17
            S17: u1,
            /// S18
            S18: u1,
            /// S19
            S19: u1,
            /// S20
            S20: u1,
            /// S21
            S21: u1,
            /// S22
            S22: u1,
            /// S23
            S23: u1,
            /// S24
            S24: u1,
            /// S25
            S25: u1,
            /// S26
            S26: u1,
            /// S27
            S27: u1,
            /// S28
            S28: u1,
            /// S29
            S29: u1,
            /// S30
            S30: u1,
            /// S31
            S31: u1,
        }), base_address + 0x44);

        /// address: 0x4000244c
        /// display memory
        pub const RAM_COM7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// S00
            S00: u1,
            /// S01
            S01: u1,
            /// S02
            S02: u1,
            /// S03
            S03: u1,
            /// S04
            S04: u1,
            /// S05
            S05: u1,
            /// S06
            S06: u1,
            /// S07
            S07: u1,
            /// S08
            S08: u1,
            /// S09
            S09: u1,
            /// S10
            S10: u1,
            /// S11
            S11: u1,
            /// S12
            S12: u1,
            /// S13
            S13: u1,
            /// S14
            S14: u1,
            /// S15
            S15: u1,
            /// S16
            S16: u1,
            /// S17
            S17: u1,
            /// S18
            S18: u1,
            /// S19
            S19: u1,
            /// S20
            S20: u1,
            /// S21
            S21: u1,
            /// S22
            S22: u1,
            /// S23
            S23: u1,
            /// S24
            S24: u1,
            /// S25
            S25: u1,
            /// S26
            S26: u1,
            /// S27
            S27: u1,
            /// S28
            S28: u1,
            /// S29
            S29: u1,
            /// S30
            S30: u1,
            /// S31
            S31: u1,
        }), base_address + 0x4c);
    };

    /// Touch sensing controller
    pub const TSC = struct {
        pub const base_address = 0x40024000;

        /// address: 0x40024000
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Touch sensing controller
            /// enable
            TSCE: u1,
            /// Start a new acquisition
            START: u1,
            /// Acquisition mode
            AM: u1,
            /// Synchronization pin
            /// polarity
            SYNCPOL: u1,
            /// I/O Default mode
            IODEF: u1,
            /// Max count value
            MCV: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// pulse generator prescaler
            PGPSC: u3,
            /// Spread spectrum prescaler
            SSPSC: u1,
            /// Spread spectrum enable
            SSE: u1,
            /// Spread spectrum deviation
            SSD: u7,
            /// Charge transfer pulse low
            CTPL: u4,
            /// Charge transfer pulse high
            CTPH: u4,
        }), base_address + 0x0);

        /// address: 0x40024004
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of acquisition interrupt
            /// enable
            EOAIE: u1,
            /// Max count error interrupt
            /// enable
            MCEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4);

        /// address: 0x40024008
        /// interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of acquisition interrupt
            /// clear
            EOAIC: u1,
            /// Max count error interrupt
            /// clear
            MCEIC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x8);

        /// address: 0x4002400c
        /// interrupt status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of acquisition flag
            EOAF: u1,
            /// Max count error flag
            MCEF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0xc);

        /// address: 0x40024010
        /// I/O hysteresis control
        /// register
        pub const IOHCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// G1_IO1
            G1_IO1: u1,
            /// G1_IO2
            G1_IO2: u1,
            /// G1_IO3
            G1_IO3: u1,
            /// G1_IO4
            G1_IO4: u1,
            /// G2_IO1
            G2_IO1: u1,
            /// G2_IO2
            G2_IO2: u1,
            /// G2_IO3
            G2_IO3: u1,
            /// G2_IO4
            G2_IO4: u1,
            /// G3_IO1
            G3_IO1: u1,
            /// G3_IO2
            G3_IO2: u1,
            /// G3_IO3
            G3_IO3: u1,
            /// G3_IO4
            G3_IO4: u1,
            /// G4_IO1
            G4_IO1: u1,
            /// G4_IO2
            G4_IO2: u1,
            /// G4_IO3
            G4_IO3: u1,
            /// G4_IO4
            G4_IO4: u1,
            /// G5_IO1
            G5_IO1: u1,
            /// G5_IO2
            G5_IO2: u1,
            /// G5_IO3
            G5_IO3: u1,
            /// G5_IO4
            G5_IO4: u1,
            /// G6_IO1
            G6_IO1: u1,
            /// G6_IO2
            G6_IO2: u1,
            /// G6_IO3
            G6_IO3: u1,
            /// G6_IO4
            G6_IO4: u1,
            /// G7_IO1
            G7_IO1: u1,
            /// G7_IO2
            G7_IO2: u1,
            /// G7_IO3
            G7_IO3: u1,
            /// G7_IO4
            G7_IO4: u1,
            /// G8_IO1
            G8_IO1: u1,
            /// G8_IO2
            G8_IO2: u1,
            /// G8_IO3
            G8_IO3: u1,
            /// G8_IO4
            G8_IO4: u1,
        }), base_address + 0x10);

        /// address: 0x40024018
        /// I/O analog switch control
        /// register
        pub const IOASCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// G1_IO1
            G1_IO1: u1,
            /// G1_IO2
            G1_IO2: u1,
            /// G1_IO3
            G1_IO3: u1,
            /// G1_IO4
            G1_IO4: u1,
            /// G2_IO1
            G2_IO1: u1,
            /// G2_IO2
            G2_IO2: u1,
            /// G2_IO3
            G2_IO3: u1,
            /// G2_IO4
            G2_IO4: u1,
            /// G3_IO1
            G3_IO1: u1,
            /// G3_IO2
            G3_IO2: u1,
            /// G3_IO3
            G3_IO3: u1,
            /// G3_IO4
            G3_IO4: u1,
            /// G4_IO1
            G4_IO1: u1,
            /// G4_IO2
            G4_IO2: u1,
            /// G4_IO3
            G4_IO3: u1,
            /// G4_IO4
            G4_IO4: u1,
            /// G5_IO1
            G5_IO1: u1,
            /// G5_IO2
            G5_IO2: u1,
            /// G5_IO3
            G5_IO3: u1,
            /// G5_IO4
            G5_IO4: u1,
            /// G6_IO1
            G6_IO1: u1,
            /// G6_IO2
            G6_IO2: u1,
            /// G6_IO3
            G6_IO3: u1,
            /// G6_IO4
            G6_IO4: u1,
            /// G7_IO1
            G7_IO1: u1,
            /// G7_IO2
            G7_IO2: u1,
            /// G7_IO3
            G7_IO3: u1,
            /// G7_IO4
            G7_IO4: u1,
            /// G8_IO1
            G8_IO1: u1,
            /// G8_IO2
            G8_IO2: u1,
            /// G8_IO3
            G8_IO3: u1,
            /// G8_IO4
            G8_IO4: u1,
        }), base_address + 0x18);

        /// address: 0x40024020
        /// I/O sampling control register
        pub const IOSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// G1_IO1
            G1_IO1: u1,
            /// G1_IO2
            G1_IO2: u1,
            /// G1_IO3
            G1_IO3: u1,
            /// G1_IO4
            G1_IO4: u1,
            /// G2_IO1
            G2_IO1: u1,
            /// G2_IO2
            G2_IO2: u1,
            /// G2_IO3
            G2_IO3: u1,
            /// G2_IO4
            G2_IO4: u1,
            /// G3_IO1
            G3_IO1: u1,
            /// G3_IO2
            G3_IO2: u1,
            /// G3_IO3
            G3_IO3: u1,
            /// G3_IO4
            G3_IO4: u1,
            /// G4_IO1
            G4_IO1: u1,
            /// G4_IO2
            G4_IO2: u1,
            /// G4_IO3
            G4_IO3: u1,
            /// G4_IO4
            G4_IO4: u1,
            /// G5_IO1
            G5_IO1: u1,
            /// G5_IO2
            G5_IO2: u1,
            /// G5_IO3
            G5_IO3: u1,
            /// G5_IO4
            G5_IO4: u1,
            /// G6_IO1
            G6_IO1: u1,
            /// G6_IO2
            G6_IO2: u1,
            /// G6_IO3
            G6_IO3: u1,
            /// G6_IO4
            G6_IO4: u1,
            /// G7_IO1
            G7_IO1: u1,
            /// G7_IO2
            G7_IO2: u1,
            /// G7_IO3
            G7_IO3: u1,
            /// G7_IO4
            G7_IO4: u1,
            /// G8_IO1
            G8_IO1: u1,
            /// G8_IO2
            G8_IO2: u1,
            /// G8_IO3
            G8_IO3: u1,
            /// G8_IO4
            G8_IO4: u1,
        }), base_address + 0x20);

        /// address: 0x40024028
        /// I/O channel control register
        pub const IOCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// G1_IO1
            G1_IO1: u1,
            /// G1_IO2
            G1_IO2: u1,
            /// G1_IO3
            G1_IO3: u1,
            /// G1_IO4
            G1_IO4: u1,
            /// G2_IO1
            G2_IO1: u1,
            /// G2_IO2
            G2_IO2: u1,
            /// G2_IO3
            G2_IO3: u1,
            /// G2_IO4
            G2_IO4: u1,
            /// G3_IO1
            G3_IO1: u1,
            /// G3_IO2
            G3_IO2: u1,
            /// G3_IO3
            G3_IO3: u1,
            /// G3_IO4
            G3_IO4: u1,
            /// G4_IO1
            G4_IO1: u1,
            /// G4_IO2
            G4_IO2: u1,
            /// G4_IO3
            G4_IO3: u1,
            /// G4_IO4
            G4_IO4: u1,
            /// G5_IO1
            G5_IO1: u1,
            /// G5_IO2
            G5_IO2: u1,
            /// G5_IO3
            G5_IO3: u1,
            /// G5_IO4
            G5_IO4: u1,
            /// G6_IO1
            G6_IO1: u1,
            /// G6_IO2
            G6_IO2: u1,
            /// G6_IO3
            G6_IO3: u1,
            /// G6_IO4
            G6_IO4: u1,
            /// G7_IO1
            G7_IO1: u1,
            /// G7_IO2
            G7_IO2: u1,
            /// G7_IO3
            G7_IO3: u1,
            /// G7_IO4
            G7_IO4: u1,
            /// G8_IO1
            G8_IO1: u1,
            /// G8_IO2
            G8_IO2: u1,
            /// G8_IO3
            G8_IO3: u1,
            /// G8_IO4
            G8_IO4: u1,
        }), base_address + 0x28);

        /// address: 0x40024030
        /// I/O group control status
        /// register
        pub const IOGCSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog I/O group x enable
            G1E: u1,
            /// Analog I/O group x enable
            G2E: u1,
            /// Analog I/O group x enable
            G3E: u1,
            /// Analog I/O group x enable
            G4E: u1,
            /// Analog I/O group x enable
            G5E: u1,
            /// Analog I/O group x enable
            G6E: u1,
            /// Analog I/O group x enable
            G7E: u1,
            /// Analog I/O group x enable
            G8E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Analog I/O group x status
            G1S: u1,
            /// Analog I/O group x status
            G2S: u1,
            /// Analog I/O group x status
            G3S: u1,
            /// Analog I/O group x status
            G4S: u1,
            /// Analog I/O group x status
            G5S: u1,
            /// Analog I/O group x status
            G6S: u1,
            /// Analog I/O group x status
            G7S: u1,
            /// Analog I/O group x status
            G8S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x30);

        /// address: 0x40024034
        /// I/O group x counter register
        pub const IOG1CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x34);

        /// address: 0x40024038
        /// I/O group x counter register
        pub const IOG2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x38);

        /// address: 0x4002403c
        /// I/O group x counter register
        pub const IOG3CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x3c);

        /// address: 0x40024040
        /// I/O group x counter register
        pub const IOG4CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x40);

        /// address: 0x40024044
        /// I/O group x counter register
        pub const IOG5CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x44);

        /// address: 0x40024048
        /// I/O group x counter register
        pub const IOG6CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x48);

        /// address: 0x4002404c
        /// I/O group x counter register
        pub const IOG7CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x4c);

        /// address: 0x40024050
        /// I/O group x counter register
        pub const IOG8CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter value
            CNT: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x50);
    };

    /// Independent watchdog
    pub const IWDG = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Key register
        pub const KR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Key value (write only, read
            /// 0x0000)
            KEY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003004
        /// Prescaler register
        pub const PR = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x4);

        /// address: 0x40003008
        /// Reload register
        pub const RLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter reload
            /// value
            RL: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000300c
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog prescaler value
            /// update
            PVU: u1,
            /// Watchdog counter reload value
            /// update
            RVU: u1,
            /// Watchdog counter window value
            /// update
            WVU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xc);

        /// address: 0x40003010
        /// Window register
        pub const WINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter window
            /// value
            WIN: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x10);
    };

    /// System window watchdog
    pub const WWDG = struct {
        pub const base_address = 0x40002c00;

        /// address: 0x40002c00
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit counter (MSB to LSB)
            T: u7,
            /// Activation bit
            WDGA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40002c04
        /// Configuration register
        pub const CFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit window value
            W: u7,
            /// Timer base
            WDGTB: u2,
            /// Early wakeup interrupt
            EWI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x40002c08
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Early wakeup interrupt
            /// flag
            EWIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);
    };

    /// Comparator
    pub const COMP = struct {
        pub const base_address = 0x40010200;

        /// address: 0x40010200
        /// Comparator 1 control and status
        /// register
        pub const COMP1_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 1 enable bit
            COMP1_EN: u1,
            reserved0: u1,
            /// Power Mode of the comparator
            /// 1
            COMP1_PWRMODE: u2,
            /// Comparator 1 Input Minus connection
            /// configuration bit
            COMP1_INMSEL: u3,
            /// Comparator1 input plus selection
            /// bit
            COMP1_INPSEL: u2,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Comparator 1 polarity selection
            /// bit
            COMP1_POLARITY: u1,
            /// Comparator 1 hysteresis selection
            /// bits
            COMP1_HYST: u2,
            /// Comparator 1 blanking source selection
            /// bits
            COMP1_BLANKING: u3,
            reserved7: u1,
            /// Scaler bridge enable
            COMP1_BRGEN: u1,
            /// Voltage scaler enable bit
            COMP1_SCALEN: u1,
            reserved8: u1,
            /// comparator 1 input minus extended
            /// selection bits
            COMP1_INMESEL: u2,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Comparator 1 output status
            /// bit
            COMP1_VALUE: u1,
            /// COMP1_CSR register lock
            /// bit
            COMP1_LOCK: u1,
        }), base_address + 0x0);

        /// address: 0x40010204
        /// Comparator 2 control and status
        /// register
        pub const COMP2_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 2 enable bit
            COMP2_EN: u1,
            reserved0: u1,
            /// Power Mode of the comparator
            /// 2
            COMP2_PWRMODE: u2,
            /// Comparator 2 Input Minus connection
            /// configuration bit
            COMP2_INMSEL: u3,
            /// Comparator 2 Input Plus connection
            /// configuration bit
            COMP2_INPSEL: u2,
            /// Windows mode selection bit
            COMP2_WINMODE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Comparator 2 polarity selection
            /// bit
            COMP2_POLARITY: u1,
            /// Comparator 2 hysteresis selection
            /// bits
            COMP2_HYST: u2,
            /// Comparator 2 blanking source selection
            /// bits
            COMP2_BLANKING: u3,
            reserved6: u1,
            /// Scaler bridge enable
            COMP2_BRGEN: u1,
            /// Voltage scaler enable bit
            COMP2_SCALEN: u1,
            reserved7: u1,
            /// comparator 2 input minus extended
            /// selection bits
            COMP2_INMESEL: u2,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Comparator 2 output status
            /// bit
            COMP2_VALUE: u1,
            /// COMP2_CSR register lock
            /// bit
            COMP2_LOCK: u1,
        }), base_address + 0x4);
    };

    /// Firewall
    pub const FIREWALL = struct {
        pub const base_address = 0x40011c00;

        /// address: 0x40011c00
        /// Code segment start address
        pub const CSSA = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// code segment start address
            ADD: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40011c04
        /// Code segment length
        pub const CSL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// code segment length
            LENG: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x4);

        /// address: 0x40011c08
        /// Non-volatile data segment start
        /// address
        pub const NVDSSA = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Non-volatile data segment start
            /// address
            ADD: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x40011c0c
        /// Non-volatile data segment
        /// length
        pub const NVDSL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Non-volatile data segment
            /// length
            LENG: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0xc);

        /// address: 0x40011c10
        /// Volatile data segment start
        /// address
        pub const VDSSA = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Volatile data segment start
            /// address
            ADD: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40011c14
        /// Volatile data segment length
        pub const VDSL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-volatile data segment
            /// length
            LENG: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40011c20
        /// Configuration register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Firewall pre alarm
            FPA: u1,
            /// Volatile data shared
            VDS: u1,
            /// Volatile data execution
            VDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x20);
    };

    /// Inter-integrated circuit
    pub const I2C1 = struct {
        pub const base_address = 0x40005400;

        /// address: 0x40005400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005408
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000540c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005410
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005414
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005418
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000541c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005420
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005424
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005428
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C3 = struct {
        pub const base_address = 0x40005c00;

        /// address: 0x40005c00
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005c04
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005c08
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40005c0c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005c10
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005c14
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005c18
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x40005c1c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005c20
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005c24
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005c28
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C2 = struct {
        pub const base_address = 0x40005800;

        /// address: 0x40005800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005808
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000580c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005810
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005814
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005818
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000581c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005820
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005824
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005828
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C4 = struct {
        pub const base_address = 0x40008400;

        /// address: 0x40008400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40008404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40008408
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000840c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40008410
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40008414
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40008418
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000841c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40008420
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40008424
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40008428
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };

    /// Flash
    pub const FLASH = struct {
        pub const base_address = 0x40022000;

        /// address: 0x40022000
        /// Access control register
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Latency
            LATENCY: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Prefetch enable
            PRFTEN: u1,
            /// Instruction cache enable
            ICEN: u1,
            /// Data cache enable
            DCEN: u1,
            /// Instruction cache reset
            ICRST: u1,
            /// Data cache reset
            DCRST: u1,
            /// Flash Power-down mode during Low-power
            /// run mode
            RUN_PD: u1,
            /// Flash Power-down mode during Low-power
            /// sleep mode
            SLEEP_PD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x0);

        /// address: 0x40022004
        /// Power down key register
        pub const PDKEYR = @intToPtr(*volatile u32, base_address + 0x4);

        /// address: 0x40022008
        /// Flash key register
        pub const KEYR = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4002200c
        /// Option byte key register
        pub const OPTKEYR = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40022010
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of operation
            EOP: u1,
            /// Operation error
            OPERR: u1,
            reserved0: u1,
            /// Programming error
            PROGERR: u1,
            /// Write protected error
            WRPERR: u1,
            /// Programming alignment
            /// error
            PGAERR: u1,
            /// Size error
            SIZERR: u1,
            /// Programming sequence error
            PGSERR: u1,
            /// Fast programming data miss
            /// error
            MISERR: u1,
            /// Fast programming error
            FASTERR: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// PCROP read error
            RDERR: u1,
            /// Option validity error
            OPTVERR: u1,
            /// Busy
            BSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x10);

        /// address: 0x40022014
        /// Flash control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programming
            PG: u1,
            /// Page erase
            PER: u1,
            /// Bank 1 Mass erase
            MER1: u1,
            /// Page number
            PNB: u8,
            /// Bank erase
            BKER: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Bank 2 Mass erase
            MER2: u1,
            /// Start
            START: u1,
            /// Options modification start
            OPTSTRT: u1,
            /// Fast programming
            FSTPG: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// End of operation interrupt
            /// enable
            EOPIE: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// PCROP read error interrupt
            /// enable
            RDERRIE: u1,
            /// Force the option byte
            /// loading
            OBL_LAUNCH: u1,
            reserved8: u1,
            reserved9: u1,
            /// Options Lock
            OPTLOCK: u1,
            /// FLASH_CR Lock
            LOCK: u1,
        }), base_address + 0x14);

        /// address: 0x40022018
        /// Flash ECC register
        pub const ECCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ECC fail address
            ADDR_ECC: u19,
            /// ECC fail bank
            BK_ECC: u1,
            /// System Flash ECC fail
            SYSF_ECC: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// ECC correction interrupt
            /// enable
            ECCIE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// ECC correction
            ECCC: u1,
            /// ECC detection
            ECCD: u1,
        }), base_address + 0x18);

        /// address: 0x40022020
        /// Flash option register
        pub const OPTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read protection level
            RDP: u8,
            /// BOR reset Level
            BOR_LEV: u3,
            reserved0: u1,
            /// nRST_STOP
            nRST_STOP: u1,
            /// nRST_STDBY
            nRST_STDBY: u1,
            /// nRST_SHDW
            nRST_SHDW: u1,
            reserved1: u1,
            /// Independent watchdog
            /// selection
            IWDG_SW: u1,
            /// Independent watchdog counter freeze in
            /// Stop mode
            IWDG_STOP: u1,
            /// Independent watchdog counter freeze in
            /// Standby mode
            IWDG_STDBY: u1,
            /// Window watchdog selection
            WWDG_SW: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Boot configuration
            nBOOT1: u1,
            /// SRAM2 parity check enable
            SRAM2_PE: u1,
            /// SRAM2 Erase when system
            /// reset
            SRAM2_RST: u1,
            /// Software BOOT0
            nSWBOOT0: u1,
            /// nBOOT0 option bit
            nBOOT0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x40022024
        /// Flash Bank 1 PCROP Start address
        /// register
        pub const PCROP1SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bank 1 PCROP area start
            /// offset
            PCROP1_STRT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x40022028
        /// Flash Bank 1 PCROP End address
        /// register
        pub const PCROP1ER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bank 1 PCROP area end
            /// offset
            PCROP1_END: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// PCROP area preserved when RDP level
            /// decreased
            PCROP_RDP: u1,
        }), base_address + 0x28);

        /// address: 0x4002202c
        /// Flash Bank 1 WRP area A address
        /// register
        pub const WRP1AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WRP first area A start
            /// offset
            WRP1A_STRT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// WRP first area A end
            /// offset
            WRP1A_END: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x2c);

        /// address: 0x40022030
        /// Flash Bank 1 WRP area B address
        /// register
        pub const WRP1BR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bank 1 WRP second area B start
            /// offset
            WRP1B_STRT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Bank 1 WRP second area B end
            /// offset
            WRP1B_END: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x30);
    };

    /// Reset and clock control
    pub const RCC = struct {
        pub const base_address = 0x40021000;

        /// address: 0x40021000
        /// Clock control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MSI clock enable
            MSION: u1,
            /// MSI clock ready flag
            MSIRDY: u1,
            /// MSI clock PLL enable
            MSIPLLEN: u1,
            /// MSI clock range selection
            MSIRGSEL: u1,
            /// MSI clock ranges
            MSIRANGE: u4,
            /// HSI clock enable
            HSION: u1,
            /// HSI always enable for peripheral
            /// kernels
            HSIKERON: u1,
            /// HSI clock ready flag
            HSIRDY: u1,
            /// HSI automatic start from
            /// Stop
            HSIASFS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// HSE clock enable
            HSEON: u1,
            /// HSE clock ready flag
            HSERDY: u1,
            /// HSE crystal oscillator
            /// bypass
            HSEBYP: u1,
            /// Clock security system
            /// enable
            CSSON: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Main PLL enable
            PLLON: u1,
            /// Main PLL clock ready flag
            PLLRDY: u1,
            /// SAI1 PLL enable
            PLLSAI1ON: u1,
            /// SAI1 PLL clock ready flag
            PLLSAI1RDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40021004
        /// Internal clock sources calibration
        /// register
        pub const ICSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MSI clock calibration
            MSICAL: u8,
            /// MSI clock trimming
            MSITRIM: u8,
            /// HSI clock calibration
            HSICAL: u8,
            /// HSI clock trimming
            HSITRIM: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x4);

        /// address: 0x40021008
        /// Clock configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// System clock switch
            SW: u2,
            /// System clock switch status
            SWS: u2,
            /// AHB prescaler
            HPRE: u4,
            /// PB low-speed prescaler
            /// (APB1)
            PPRE1: u3,
            /// APB high-speed prescaler
            /// (APB2)
            PPRE2: u3,
            reserved0: u1,
            /// Wakeup from Stop and CSS backup clock
            /// selection
            STOPWUCK: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Microcontroller clock
            /// output
            MCOSEL: u3,
            reserved9: u1,
            /// Microcontroller clock output
            /// prescaler
            MCOPRE: u3,
            padding0: u1,
        }), base_address + 0x8);

        /// address: 0x4002100c
        /// PLL configuration register
        pub const PLLCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Main PLL, PLLSAI1 and PLLSAI2 entry
            /// clock source
            PLLSRC: u2,
            reserved0: u1,
            reserved1: u1,
            /// Division factor for the main PLL and
            /// audio PLL (PLLSAI1 and PLLSAI2) input
            /// clock
            PLLM: u3,
            reserved2: u1,
            /// Main PLL multiplication factor for
            /// VCO
            PLLN: u7,
            reserved3: u1,
            /// Main PLL PLLSAI3CLK output
            /// enable
            PLLPEN: u1,
            /// Main PLL division factor for PLLSAI3CLK
            /// (SAI1 and SAI2 clock)
            PLLP: u1,
            reserved4: u1,
            reserved5: u1,
            /// Main PLL PLLUSB1CLK output
            /// enable
            PLLQEN: u1,
            /// Main PLL division factor for
            /// PLLUSB1CLK(48 MHz clock)
            PLLQ: u2,
            reserved6: u1,
            /// Main PLL PLLCLK output
            /// enable
            PLLREN: u1,
            /// Main PLL division factor for PLLCLK
            /// (system clock)
            PLLR: u2,
            /// Main PLL division factor for
            /// PLLSAI2CLK
            PLLPDIV: u5,
        }), base_address + 0xc);

        /// address: 0x40021010
        /// PLLSAI1 configuration register
        pub const PLLSAI1CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// SAI1PLL multiplication factor for
            /// VCO
            PLLSAI1N: u7,
            reserved8: u1,
            /// SAI1PLL PLLSAI1CLK output
            /// enable
            PLLSAI1PEN: u1,
            /// SAI1PLL division factor for PLLSAI1CLK
            /// (SAI1 or SAI2 clock)
            PLLSAI1P: u1,
            reserved9: u1,
            reserved10: u1,
            /// SAI1PLL PLLUSB2CLK output
            /// enable
            PLLSAI1QEN: u1,
            /// SAI1PLL division factor for PLLUSB2CLK
            /// (48 MHz clock)
            PLLSAI1Q: u2,
            reserved11: u1,
            /// PLLSAI1 PLLADC1CLK output
            /// enable
            PLLSAI1REN: u1,
            /// PLLSAI1 division factor for PLLADC1CLK
            /// (ADC clock)
            PLLSAI1R: u2,
            /// PLLSAI1 division factor for
            /// PLLSAI1CLK
            PLLSAI1PDIV: u5,
        }), base_address + 0x10);

        /// address: 0x40021018
        /// Clock interrupt enable
        /// register
        pub const CIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt enable
            LSIRDYIE: u1,
            /// LSE ready interrupt enable
            LSERDYIE: u1,
            /// MSI ready interrupt enable
            MSIRDYIE: u1,
            /// HSI ready interrupt enable
            HSIRDYIE: u1,
            /// HSE ready interrupt enable
            HSERDYIE: u1,
            /// PLL ready interrupt enable
            PLLRDYIE: u1,
            /// PLLSAI1 ready interrupt
            /// enable
            PLLSAI1RDYIE: u1,
            reserved0: u1,
            reserved1: u1,
            /// LSE clock security system interrupt
            /// enable
            LSECSSIE: u1,
            /// HSI48 ready interrupt
            /// enable
            HSI48RDYIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x18);

        /// address: 0x4002101c
        /// Clock interrupt flag register
        pub const CIFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt flag
            LSIRDYF: u1,
            /// LSE ready interrupt flag
            LSERDYF: u1,
            /// MSI ready interrupt flag
            MSIRDYF: u1,
            /// HSI ready interrupt flag
            HSIRDYF: u1,
            /// HSE ready interrupt flag
            HSERDYF: u1,
            /// PLL ready interrupt flag
            PLLRDYF: u1,
            /// PLLSAI1 ready interrupt
            /// flag
            PLLSAI1RDYF: u1,
            reserved0: u1,
            /// Clock security system interrupt
            /// flag
            CSSF: u1,
            /// LSE Clock security system interrupt
            /// flag
            LSECSSF: u1,
            /// HSI48 ready interrupt flag
            HSI48RDYF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x1c);

        /// address: 0x40021020
        /// Clock interrupt clear register
        pub const CICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt clear
            LSIRDYC: u1,
            /// LSE ready interrupt clear
            LSERDYC: u1,
            /// MSI ready interrupt clear
            MSIRDYC: u1,
            /// HSI ready interrupt clear
            HSIRDYC: u1,
            /// HSE ready interrupt clear
            HSERDYC: u1,
            /// PLL ready interrupt clear
            PLLRDYC: u1,
            /// PLLSAI1 ready interrupt
            /// clear
            PLLSAI1RDYC: u1,
            reserved0: u1,
            /// Clock security system interrupt
            /// clear
            CSSC: u1,
            /// LSE Clock security system interrupt
            /// clear
            LSECSSC: u1,
            /// HSI48 oscillator ready interrupt
            /// clear
            HSI48RDYC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x20);

        /// address: 0x40021028
        /// AHB1 peripheral reset register
        pub const AHB1RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA1 reset
            DMA1RST: u1,
            /// DMA2 reset
            DMA2RST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Flash memory interface
            /// reset
            FLASHRST: u1,
            reserved6: u1,
            reserved7: u1,
            /// CRC reset
            CRCRST: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Touch Sensing Controller
            /// reset
            TSCRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x28);

        /// address: 0x4002102c
        /// AHB2 peripheral reset register
        pub const AHB2RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IO port A reset
            GPIOARST: u1,
            /// IO port B reset
            GPIOBRST: u1,
            /// IO port C reset
            GPIOCRST: u1,
            /// IO port D reset
            GPIODRST: u1,
            /// IO port E reset
            GPIOERST: u1,
            reserved0: u1,
            reserved1: u1,
            /// IO port H reset
            GPIOHRST: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// ADC reset
            ADCRST: u1,
            reserved7: u1,
            reserved8: u1,
            /// AES hardware accelerator
            /// reset
            AESRST: u1,
            reserved9: u1,
            /// Random number generator
            /// reset
            RNGRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x2c);

        /// address: 0x40021030
        /// AHB3 peripheral reset register
        pub const AHB3RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Quad SPI memory interface
            /// reset
            QSPIRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x30);

        /// address: 0x40021038
        /// APB1 peripheral reset register
        /// 1
        pub const APB1RSTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 timer reset
            TIM2RST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// TIM6 timer reset
            TIM6RST: u1,
            /// TIM7 timer reset
            TIM7RST: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// LCD interface reset
            LCDRST: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// SPI2 reset
            SPI2RST: u1,
            /// SPI3 reset
            SPI3RST: u1,
            reserved10: u1,
            /// USART2 reset
            USART2RST: u1,
            /// USART1 reset
            USART1RST: u1,
            /// USART4 reset.
            USART4RST: u1,
            reserved11: u1,
            /// I2C1 reset
            I2C1RST: u1,
            /// I2C2 reset
            I2C2RST: u1,
            /// I2C3 reset
            I2C3RST: u1,
            /// CRS reset
            CRSRST: u1,
            /// CAN1 reset
            CAN1RST: u1,
            /// USB FS reset
            USBFSRST: u1,
            reserved12: u1,
            /// Power interface reset
            PWRRST: u1,
            /// DAC1 interface reset
            DAC1RST: u1,
            /// OPAMP interface reset
            OPAMPRST: u1,
            /// Low Power Timer 1 reset
            LPTIM1RST: u1,
        }), base_address + 0x38);

        /// address: 0x4002103c
        /// APB1 peripheral reset register
        /// 2
        pub const APB1RSTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low-power UART 1 reset
            LPUART1RST: u1,
            /// I2C4 reset
            I2C4RST: u1,
            /// Single wire protocol reset
            SWPMI1RST: u1,
            reserved0: u1,
            reserved1: u1,
            /// Low-power timer 2 reset
            LPTIM2RST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x3c);

        /// address: 0x40021040
        /// APB2 peripheral reset register
        pub const APB2RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// System configuration (SYSCFG)
            /// reset
            SYSCFGRST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// SDMMC reset
            SDMMCRST: u1,
            /// TIM1 timer reset
            TIM1RST: u1,
            /// SPI1 reset
            SPI1RST: u1,
            reserved9: u1,
            /// USART1 reset
            USART1RST: u1,
            reserved10: u1,
            /// TIM15 timer reset
            TIM15RST: u1,
            /// TIM16 timer reset
            TIM16RST: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Serial audio interface 1 (SAI1)
            /// reset
            SAI1RST: u1,
            reserved14: u1,
            reserved15: u1,
            /// DFSDM filter reset
            DFSDMRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x40);

        /// address: 0x40021048
        /// AHB1 peripheral clock enable
        /// register
        pub const AHB1ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA1 clock enable
            DMA1EN: u1,
            /// DMA2 clock enable
            DMA2EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Flash memory interface clock
            /// enable
            FLASHEN: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// CRC clock enable
            CRCEN: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// Touch Sensing Controller clock
            /// enable
            TSCEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x48);

        /// address: 0x4002104c
        /// AHB2 peripheral clock enable
        /// register
        pub const AHB2ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IO port A clock enable
            GPIOAEN: u1,
            /// IO port B clock enable
            GPIOBEN: u1,
            /// IO port C clock enable
            GPIOCEN: u1,
            /// IO port D clock enable
            GPIODEN: u1,
            /// IO port E clock enable
            GPIOEEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// IO port H clock enable
            GPIOHEN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// ADC clock enable
            ADCEN: u1,
            reserved7: u1,
            reserved8: u1,
            /// AES accelerator clock
            /// enable
            AESEN: u1,
            reserved9: u1,
            /// Random Number Generator clock
            /// enable
            RNGEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x4c);

        /// address: 0x40021050
        /// AHB3 peripheral clock enable
        /// register
        pub const AHB3ENR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// QSPIEN
            QSPIEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x50);

        /// address: 0x40021058
        /// APB1ENR1
        pub const APB1ENR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 timer clock enable
            TIM2EN: u1,
            /// TIM3 timer clock enable
            TIM3EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// TIM6 timer clock enable
            TIM6EN: u1,
            /// TIM7 timer clock enable
            TIM7EN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// LCD clock enable
            LCDEN: u1,
            /// RTC APB clock enable
            RTCAPBEN: u1,
            /// Window watchdog clock
            /// enable
            WWDGEN: u1,
            reserved5: u1,
            reserved6: u1,
            /// SPI1 clock enable
            SPI1EN: u1,
            /// SPI3 clock enable
            SPI3EN: u1,
            reserved7: u1,
            /// USART2 clock enable
            USART2EN: u1,
            /// USART1 clock enable
            USART1EN: u1,
            /// UART4 clock enable
            UART4EN: u1,
            reserved8: u1,
            /// I2C1 clock enable
            I2C1EN: u1,
            /// I2C2 clock enable
            I2C2EN: u1,
            /// I2C3 clock enable
            I2C3EN: u1,
            /// CRS clock enable
            CRSEN: u1,
            /// CAN1 clock enable
            CAN1EN: u1,
            /// USB FS clock enable
            USBF: u1,
            reserved9: u1,
            /// Power interface clock
            /// enable
            PWREN: u1,
            /// DAC1 interface clock
            /// enable
            DAC1EN: u1,
            /// OPAMP interface clock
            /// enable
            OPAMPEN: u1,
            /// Low power timer 1 clock
            /// enable
            LPTIM1EN: u1,
        }), base_address + 0x58);

        /// address: 0x4002105c
        /// APB1 peripheral clock enable register
        /// 2
        pub const APB1ENR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low power UART 1 clock
            /// enable
            LPUART1EN: u1,
            /// I2C4 clock enable
            I2C4EN: u1,
            /// Single wire protocol clock
            /// enable
            SWPMI1EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// LPTIM2EN
            LPTIM2EN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// DFSDMEN enable
            DFSDMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x5c);

        /// address: 0x40021060
        /// APB2ENR
        pub const APB2ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SYSCFG clock enable
            SYSCFGEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Firewall clock enable
            FIREWALLEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// SDMMC clock enable
            SDMMCEN: u1,
            /// TIM1 timer clock enable
            TIM1EN: u1,
            /// SPI1 clock enable
            SPI1EN: u1,
            reserved8: u1,
            /// USART1clock enable
            USART1EN: u1,
            reserved9: u1,
            /// TIM15 timer clock enable
            TIM15EN: u1,
            /// TIM16 timer clock enable
            TIM16EN: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// SAI1 clock enable
            SAI1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x60);

        /// address: 0x40021068
        /// AHB1 peripheral clocks enable in Sleep and
        /// Stop modes register
        pub const AHB1SMENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA1 clocks enable during Sleep and Stop
            /// modes
            DMA1SMEN: u1,
            /// DMA2 clocks enable during Sleep and Stop
            /// modes
            DMA2SMEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Flash memory interface clocks enable
            /// during Sleep and Stop modes
            FLASHSMEN: u1,
            /// SRAM1 interface clocks enable during
            /// Sleep and Stop modes
            SRAM1SMEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// CRCSMEN
            CRCSMEN: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Touch Sensing Controller clocks enable
            /// during Sleep and Stop modes
            TSCSMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x68);

        /// address: 0x4002106c
        /// AHB2 peripheral clocks enable in Sleep and
        /// Stop modes register
        pub const AHB2SMENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IO port A clocks enable during Sleep and
            /// Stop modes
            GPIOASMEN: u1,
            /// IO port B clocks enable during Sleep and
            /// Stop modes
            GPIOBSMEN: u1,
            /// IO port C clocks enable during Sleep and
            /// Stop modes
            GPIOCSMEN: u1,
            /// IO port D clocks enable during Sleep and
            /// Stop modes
            GPIODSMEN: u1,
            /// IO port E clocks enable during Sleep and
            /// Stop modes
            GPIOESMEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// IO port H clocks enable during Sleep and
            /// Stop modes
            GPIOHSMEN: u1,
            reserved2: u1,
            /// SRAM2 interface clocks enable during
            /// Sleep and Stop modes
            SRAM2SMEN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// ADC clocks enable during Sleep and Stop
            /// modes
            ADCFSSMEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// AES accelerator clocks enable during
            /// Sleep and Stop modes
            AESSMEN: u1,
            reserved8: u1,
            /// Random Number Generator clocks enable
            /// during Sleep and Stop modes
            RNGSMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x6c);

        /// address: 0x40021070
        /// AHB3 peripheral clocks enable in Sleep and
        /// Stop modes register
        pub const AHB3SMENR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// QSPISMEN
            QSPISMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x70);

        /// address: 0x40021078
        /// APB1SMENR1
        pub const APB1SMENR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 timer clocks enable during Sleep
            /// and Stop modes
            TIM2SMEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// TIM6 timer clocks enable during Sleep
            /// and Stop modes
            TIM6SMEN: u1,
            /// TIM7 timer clocks enable during Sleep
            /// and Stop modes
            TIM7SMEN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// LCD clocks enable during Sleep and Stop
            /// modes
            LCDSMEN: u1,
            /// RTC APB clock enable during Sleep and
            /// Stop modes
            RTCAPBSMEN: u1,
            /// Window watchdog clocks enable during
            /// Sleep and Stop modes
            WWDGSMEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// SPI2 clocks enable during Sleep and Stop
            /// modes
            SPI2SMEN: u1,
            /// SPI3 clocks enable during Sleep and Stop
            /// modes
            SP3SMEN: u1,
            reserved8: u1,
            /// USART1 clocks enable during Sleep and
            /// Stop modes
            USART1SMEN: u1,
            /// USART2 clocks enable during Sleep and
            /// Stop modes
            USART2SMEN: u1,
            reserved9: u1,
            reserved10: u1,
            /// I2C1 clocks enable during Sleep and Stop
            /// modes
            I2C1SMEN: u1,
            /// I2C2 clocks enable during Sleep and Stop
            /// modes
            I2C2SMEN: u1,
            /// I2C3 clocks enable during Sleep and Stop
            /// modes
            I2C3SMEN: u1,
            /// CRS clock enable during Sleep and Stop
            /// modes
            CRSSMEN: u1,
            /// CAN1 clocks enable during Sleep and Stop
            /// modes
            CAN1SMEN: u1,
            /// USB FS clock enable during Sleep and
            /// Stop modes
            USBFSSMEN: u1,
            reserved11: u1,
            /// Power interface clocks enable during
            /// Sleep and Stop modes
            PWRSMEN: u1,
            /// DAC1 interface clocks enable during
            /// Sleep and Stop modes
            DAC1SMEN: u1,
            /// OPAMP interface clocks enable during
            /// Sleep and Stop modes
            OPAMPSMEN: u1,
            /// Low power timer 1 clocks enable during
            /// Sleep and Stop modes
            LPTIM1SMEN: u1,
        }), base_address + 0x78);

        /// address: 0x4002107c
        /// APB1 peripheral clocks enable in Sleep and
        /// Stop modes register 2
        pub const APB1SMENR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low power UART 1 clocks enable during
            /// Sleep and Stop modes
            LPUART1SMEN: u1,
            reserved0: u1,
            /// Single wire protocol clocks enable
            /// during Sleep and Stop modes
            SWPMI1SMEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// LPTIM2SMEN
            LPTIM2SMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x7c);

        /// address: 0x40021080
        /// APB2SMENR
        pub const APB2SMENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SYSCFG clocks enable during Sleep and
            /// Stop modes
            SYSCFGSMEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// SDMMC clocks enable during Sleep and
            /// Stop modes
            SDMMCSMEN: u1,
            /// TIM1 timer clocks enable during Sleep
            /// and Stop modes
            TIM1SMEN: u1,
            /// SPI1 clocks enable during Sleep and Stop
            /// modes
            SPI1SMEN: u1,
            reserved9: u1,
            /// USART1clocks enable during Sleep and
            /// Stop modes
            USART1SMEN: u1,
            reserved10: u1,
            /// TIM15 timer clocks enable during Sleep
            /// and Stop modes
            TIM15SMEN: u1,
            /// TIM16 timer clocks enable during Sleep
            /// and Stop modes
            TIM16SMEN: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// SAI1 clocks enable during Sleep and Stop
            /// modes
            SAI1SMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x80);

        /// address: 0x40021088
        /// CCIPR
        pub const CCIPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART1 clock source
            /// selection
            USART1SEL: u2,
            /// USART2 clock source
            /// selection
            USART2SEL: u2,
            /// USART3 clock source
            /// selection
            USART3SEL: u2,
            /// USART4 clock source
            /// selection
            USART4SEL: u2,
            reserved0: u1,
            reserved1: u1,
            /// LPUART1 clock source
            /// selection
            LPUART1SEL: u2,
            /// I2C1 clock source
            /// selection
            I2C1SEL: u2,
            /// I2C2 clock source
            /// selection
            I2C2SEL: u2,
            /// I2C3 clock source
            /// selection
            I2C3SEL: u2,
            /// Low power timer 1 clock source
            /// selection
            LPTIM1SEL: u2,
            /// Low power timer 2 clock source
            /// selection
            LPTIM2SEL: u2,
            /// SAI1 clock source
            /// selection
            SAI1SEL: u2,
            reserved2: u1,
            reserved3: u1,
            /// 48 MHz clock source
            /// selection
            CLK48SEL: u2,
            /// ADCs clock source
            /// selection
            ADCSEL: u2,
            /// SWPMI1 clock source
            /// selection
            SWPMI1SEL: u1,
            padding0: u1,
        }), base_address + 0x88);

        /// address: 0x40021090
        /// BDCR
        pub const BDCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSE oscillator enable
            LSEON: u1,
            /// LSE oscillator ready
            LSERDY: u1,
            /// LSE oscillator bypass
            LSEBYP: u1,
            /// SE oscillator drive
            /// capability
            LSEDRV: u2,
            /// LSECSSON
            LSECSSON: u1,
            /// LSECSSD
            LSECSSD: u1,
            reserved0: u1,
            /// RTC clock source selection
            RTCSEL: u2,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// RTC clock enable
            RTCEN: u1,
            /// Backup domain software
            /// reset
            BDRST: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Low speed clock output
            /// enable
            LSCOEN: u1,
            /// Low speed clock output
            /// selection
            LSCOSEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x90);

        /// address: 0x40021094
        /// CSR
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI oscillator enable
            LSION: u1,
            /// LSI oscillator ready
            LSIRDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// SI range after Standby
            /// mode
            MSISRANGE: u4,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Remove reset flag
            RMVF: u1,
            /// Firewall reset flag
            FIREWALLRSTF: u1,
            /// Option byte loader reset
            /// flag
            OBLRSTF: u1,
            /// Pin reset flag
            PINRSTF: u1,
            /// BOR flag
            BORRSTF: u1,
            /// Software reset flag
            SFTRSTF: u1,
            /// Independent window watchdog reset
            /// flag
            IWDGRSTF: u1,
            /// Window watchdog reset flag
            WWDGRSTF: u1,
            /// Low-power reset flag
            LPWRSTF: u1,
        }), base_address + 0x94);

        /// address: 0x40021098
        /// Clock recovery RC register
        pub const CRRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// HSI48 clock enable
            HSI48ON: u1,
            /// HSI48 clock ready flag
            HSI48RDY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// HSI48 clock calibration
            HSI48CAL: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x98);
    };

    /// Power control
    pub const PWR = struct {
        pub const base_address = 0x40007000;

        /// address: 0x40007000
        /// Power control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low-power mode selection
            LPMS: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Disable backup domain write
            /// protection
            DBP: u1,
            /// Voltage scaling range
            /// selection
            VOS: u2,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Low-power run
            LPR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x0);

        /// address: 0x40007004
        /// Power control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Power voltage detector
            /// enable
            PVDE: u1,
            /// Power voltage detector level
            /// selection
            PLS: u3,
            /// Peripheral voltage monitoring 1 enable:
            /// VDDUSB vs. 1.2V
            PVME1: u1,
            /// Peripheral voltage monitoring 2 enable:
            /// VDDIO2 vs. 0.9V
            PVME2: u1,
            /// Peripheral voltage monitoring 3 enable:
            /// VDDA vs. 1.62V
            PVME3: u1,
            /// Peripheral voltage monitoring 4 enable:
            /// VDDA vs. 2.2V
            PVME4: u1,
            reserved0: u1,
            /// VDDIO2 Independent I/Os supply
            /// valid
            IOSV: u1,
            /// VDDUSB USB supply valid
            USV: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x4);

        /// address: 0x40007008
        /// Power control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable Wakeup pin WKUP1
            EWUP1: u1,
            /// Enable Wakeup pin WKUP2
            EWUP2: u1,
            /// Enable Wakeup pin WKUP3
            EWUP3: u1,
            /// Enable Wakeup pin WKUP4
            EWUP4: u1,
            /// Enable Wakeup pin WKUP5
            EWUP5: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// SRAM2 retention in Standby
            /// mode
            RRS: u1,
            reserved3: u1,
            /// Apply pull-up and pull-down
            /// configuration
            APC: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Enable internal wakeup
            /// line
            EWF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000700c
        /// Power control register 4
        pub const CR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup pin WKUP1 polarity
            WP1: u1,
            /// Wakeup pin WKUP2 polarity
            WP2: u1,
            /// Wakeup pin WKUP3 polarity
            WP3: u1,
            /// Wakeup pin WKUP4 polarity
            WP4: u1,
            /// Wakeup pin WKUP5 polarity
            WP5: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// VBAT battery charging
            /// enable
            VBE: u1,
            /// VBAT battery charging resistor
            /// selection
            VBRS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0xc);

        /// address: 0x40007010
        /// Power status register 1
        pub const SR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup flag 1
            CWUF1: u1,
            /// Wakeup flag 2
            CWUF2: u1,
            /// Wakeup flag 3
            CWUF3: u1,
            /// Wakeup flag 4
            CWUF4: u1,
            /// Wakeup flag 5
            CWUF5: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Standby flag
            CSBF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup flag internal
            WUFI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40007014
        /// Power status register 2
        pub const SR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Low-power regulator
            /// started
            REGLPS: u1,
            /// Low-power regulator flag
            REGLPF: u1,
            /// Voltage scaling flag
            VOSF: u1,
            /// Power voltage detector
            /// output
            PVDO: u1,
            /// Peripheral voltage monitoring output:
            /// VDDUSB vs. 1.2 V
            PVMO1: u1,
            /// Peripheral voltage monitoring output:
            /// VDDIO2 vs. 0.9 V
            PVMO2: u1,
            /// Peripheral voltage monitoring output:
            /// VDDA vs. 1.62 V
            PVMO3: u1,
            /// Peripheral voltage monitoring output:
            /// VDDA vs. 2.2 V
            PVMO4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40007018
        /// Power status clear register
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear wakeup flag 1
            WUF1: u1,
            /// Clear wakeup flag 2
            WUF2: u1,
            /// Clear wakeup flag 3
            WUF3: u1,
            /// Clear wakeup flag 4
            WUF4: u1,
            /// Clear wakeup flag 5
            WUF5: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Clear standby flag
            SBF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x18);

        /// address: 0x40007020
        /// Power Port A pull-up control
        /// register
        pub const PUCRA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU2: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU3: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU4: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU5: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU6: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU7: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU8: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU9: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU10: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU11: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU12: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU13: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU14: u1,
            /// Port A pull-up bit y
            /// (y=0..15)
            PU15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40007024
        /// Power Port A pull-down control
        /// register
        pub const PDCRA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD6: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD7: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD9: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD10: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD11: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD12: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD13: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD14: u1,
            /// Port A pull-down bit y
            /// (y=0..15)
            PD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x24);

        /// address: 0x40007028
        /// Power Port B pull-up control
        /// register
        pub const PUCRB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port B pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU2: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU3: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU4: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU5: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU6: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU7: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU8: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU9: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU10: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU11: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU12: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU13: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU14: u1,
            /// Port B pull-up bit y
            /// (y=0..15)
            PU15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000702c
        /// Power Port B pull-down control
        /// register
        pub const PDCRB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port B pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD6: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD7: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD9: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD10: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD11: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD12: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD13: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD14: u1,
            /// Port B pull-down bit y
            /// (y=0..15)
            PD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x40007030
        /// Power Port C pull-up control
        /// register
        pub const PUCRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port C pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU2: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU3: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU4: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU5: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU6: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU7: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU8: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU9: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU10: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU11: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU12: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU13: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU14: u1,
            /// Port C pull-up bit y
            /// (y=0..15)
            PU15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);

        /// address: 0x40007034
        /// Power Port C pull-down control
        /// register
        pub const PDCRC = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port C pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD6: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD7: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD9: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD10: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD11: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD12: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD13: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD14: u1,
            /// Port C pull-down bit y
            /// (y=0..15)
            PD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40007038
        /// Power Port D pull-up control
        /// register
        pub const PUCRD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU2: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU3: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU4: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU5: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU6: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU7: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU8: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU9: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU10: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU11: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU12: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU13: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU14: u1,
            /// Port D pull-up bit y
            /// (y=0..15)
            PU15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x4000703c
        /// Power Port D pull-down control
        /// register
        pub const PDCRD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port D pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD6: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD7: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD9: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD10: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD11: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD12: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD13: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD14: u1,
            /// Port D pull-down bit y
            /// (y=0..15)
            PD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40007040
        /// Power Port E pull-up control
        /// register
        pub const PUCRE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port E pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU2: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU3: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU4: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU5: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU6: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU7: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU8: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU9: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU10: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU11: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU12: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU13: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU14: u1,
            /// Port E pull-up bit y
            /// (y=0..15)
            PU15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40007044
        /// Power Port E pull-down control
        /// register
        pub const PDCRE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port E pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD6: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD7: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD9: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD10: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD11: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD12: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD13: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD14: u1,
            /// Port E pull-down bit y
            /// (y=0..15)
            PD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40007048
        /// Power Port F pull-up control
        /// register
        pub const PUCRF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port F pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU2: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU3: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU4: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU5: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU6: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU7: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU8: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU9: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU10: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU11: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU12: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU13: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU14: u1,
            /// Port F pull-up bit y
            /// (y=0..15)
            PU15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4000704c
        /// Power Port F pull-down control
        /// register
        pub const PDCRF = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port F pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD6: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD7: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD9: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD10: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD11: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD12: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD13: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD14: u1,
            /// Port F pull-down bit y
            /// (y=0..15)
            PD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40007050
        /// Power Port G pull-up control
        /// register
        pub const PUCRG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port G pull-up bit y
            /// (y=0..15)
            PU0: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU1: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU2: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU3: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU4: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU5: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU6: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU7: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU8: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU9: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU10: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU11: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU12: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU13: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU14: u1,
            /// Port G pull-up bit y
            /// (y=0..15)
            PU15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x50);

        /// address: 0x40007054
        /// Power Port G pull-down control
        /// register
        pub const PDCRG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port G pull-down bit y
            /// (y=0..15)
            PD0: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD1: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD2: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD3: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD4: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD5: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD6: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD7: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD8: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD9: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD10: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD11: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD12: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD13: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD14: u1,
            /// Port G pull-down bit y
            /// (y=0..15)
            PD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x54);

        /// address: 0x40007058
        /// Power Port H pull-up control
        /// register
        pub const PUCRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port H pull-up bit y
            /// (y=0..1)
            PU0: u1,
            /// Port H pull-up bit y
            /// (y=0..1)
            PU1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x58);

        /// address: 0x4000705c
        /// Power Port H pull-down control
        /// register
        pub const PDCRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port H pull-down bit y
            /// (y=0..1)
            PD0: u1,
            /// Port H pull-down bit y
            /// (y=0..1)
            PD1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x5c);
    };

    /// System configuration controller
    pub const SYSCFG = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// memory remap register
        pub const MEMRMP = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory mapping selection
            MEM_MODE: u3,
            /// QUADSPI memory mapping
            /// swap
            QFS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Flash Bank mode selection
            FB_MODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);

        /// address: 0x40010004
        /// configuration register 1
        pub const CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Firewall disable
            FWDIS: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// I/O analog switch voltage booster
            /// enable
            BOOSTEN: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Fast-mode Plus (Fm+) driving capability
            /// activation on PB6
            I2C_PB6_FMP: u1,
            /// Fast-mode Plus (Fm+) driving capability
            /// activation on PB7
            I2C_PB7_FMP: u1,
            /// Fast-mode Plus (Fm+) driving capability
            /// activation on PB8
            I2C_PB8_FMP: u1,
            /// Fast-mode Plus (Fm+) driving capability
            /// activation on PB9
            I2C_PB9_FMP: u1,
            /// I2C1 Fast-mode Plus driving capability
            /// activation
            I2C1_FMP: u1,
            /// I2C2 Fast-mode Plus driving capability
            /// activation
            I2C2_FMP: u1,
            /// I2C3 Fast-mode Plus driving capability
            /// activation
            I2C3_FMP: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            /// Floating Point Unit interrupts enable
            /// bits
            FPU_IE: u6,
        }), base_address + 0x4);

        /// address: 0x40010008
        /// external interrupt configuration register
        /// 1
        pub const EXTICR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 0 configuration bits
            EXTI0: u3,
            reserved0: u1,
            /// EXTI 1 configuration bits
            EXTI1: u3,
            reserved1: u1,
            /// EXTI 2 configuration bits
            EXTI2: u3,
            reserved2: u1,
            /// EXTI 3 configuration bits
            EXTI3: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4001000c
        /// external interrupt configuration register
        /// 2
        pub const EXTICR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 4 configuration bits
            EXTI4: u3,
            reserved0: u1,
            /// EXTI 5 configuration bits
            EXTI5: u3,
            reserved1: u1,
            /// EXTI 6 configuration bits
            EXTI6: u3,
            reserved2: u1,
            /// EXTI 7 configuration bits
            EXTI7: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40010010
        /// external interrupt configuration register
        /// 3
        pub const EXTICR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI 8 configuration bits
            EXTI8: u3,
            reserved0: u1,
            /// EXTI 9 configuration bits
            EXTI9: u3,
            reserved1: u1,
            /// EXTI 10 configuration bits
            EXTI10: u3,
            reserved2: u1,
            /// EXTI 11 configuration bits
            EXTI11: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x10);

        /// address: 0x40010014
        /// external interrupt configuration register
        /// 4
        pub const EXTICR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI12 configuration bits
            EXTI12: u3,
            reserved0: u1,
            /// EXTI13 configuration bits
            EXTI13: u3,
            reserved1: u1,
            /// EXTI14 configuration bits
            EXTI14: u3,
            reserved2: u1,
            /// EXTI15 configuration bits
            EXTI15: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x14);

        /// address: 0x40010018
        /// SCSR
        pub const SCSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SRAM2 Erase
            SRAM2ER: u1,
            /// SRAM2 busy by erase
            /// operation
            SRAM2BSY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x18);

        /// address: 0x4001001c
        /// CFGR2
        pub const CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OCKUP (Hardfault) output enable
            /// bit
            CLL: u1,
            /// SRAM2 parity lock bit
            SPL: u1,
            /// PVD lock enable bit
            PVDL: u1,
            /// ECC Lock
            ECCL: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// SRAM2 parity error flag
            SPF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x1c);

        /// address: 0x40010020
        /// SWPR
        pub const SWPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// P0WP
            P0WP: u1,
            /// P1WP
            P1WP: u1,
            /// P2WP
            P2WP: u1,
            /// P3WP
            P3WP: u1,
            /// P4WP
            P4WP: u1,
            /// P5WP
            P5WP: u1,
            /// P6WP
            P6WP: u1,
            /// P7WP
            P7WP: u1,
            /// P8WP
            P8WP: u1,
            /// P9WP
            P9WP: u1,
            /// P10WP
            P10WP: u1,
            /// P11WP
            P11WP: u1,
            /// P12WP
            P12WP: u1,
            /// P13WP
            P13WP: u1,
            /// P14WP
            P14WP: u1,
            /// P15WP
            P15WP: u1,
            /// P16WP
            P16WP: u1,
            /// P17WP
            P17WP: u1,
            /// P18WP
            P18WP: u1,
            /// P19WP
            P19WP: u1,
            /// P20WP
            P20WP: u1,
            /// P21WP
            P21WP: u1,
            /// P22WP
            P22WP: u1,
            /// P23WP
            P23WP: u1,
            /// P24WP
            P24WP: u1,
            /// P25WP
            P25WP: u1,
            /// P26WP
            P26WP: u1,
            /// P27WP
            P27WP: u1,
            /// P28WP
            P28WP: u1,
            /// P29WP
            P29WP: u1,
            /// P30WP
            P30WP: u1,
            /// SRAM2 page 31 write
            /// protection
            P31WP: u1,
        }), base_address + 0x20);

        /// address: 0x40010024
        /// SKR
        pub const SKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SRAM2 write protection key for software
            /// erase
            KEY: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);
    };

    /// Random number generator
    pub const RNG = struct {
        pub const base_address = 0x50060800;

        /// address: 0x50060800
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Random number generator
            /// enable
            RNGEN: u1,
            /// Interrupt enable
            IE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x0);

        /// address: 0x50060804
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data ready
            DRDY: u1,
            /// Clock error current status
            CECS: u1,
            /// Seed error current status
            SECS: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock error interrupt
            /// status
            CEIS: u1,
            /// Seed error interrupt
            /// status
            SEIS: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x50060808
        /// data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Random data
            RNDATA: u32,
        }), base_address + 0x8);
    };

    /// Advanced encryption standard hardware
    /// accelerator
    pub const AES = struct {
        pub const base_address = 0x50060000;

        /// address: 0x50060000
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AES enable
            EN: u1,
            /// Data type selection (for data in and
            /// data out to/from the cryptographic
            /// block)
            DATATYPE: u2,
            /// AES operating mode
            MODE: u2,
            /// AES chaining mode
            CHMOD: u2,
            /// Computation Complete Flag
            /// Clear
            CCFC: u1,
            /// Error clear
            ERRC: u1,
            /// CCF flag interrupt enable
            CCFIE: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// Enable DMA management of data input
            /// phase
            DMAINEN: u1,
            /// Enable DMA management of data output
            /// phase
            DMAOUTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x0);

        /// address: 0x50060004
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Computation complete flag
            CCF: u1,
            /// Read error flag
            RDERR: u1,
            /// Write error flag
            WRERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0x50060008
        /// data input register
        pub const DINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Input Register
            AES_DINR: u32,
        }), base_address + 0x8);

        /// address: 0x5006000c
        /// data output register
        pub const DOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data output register
            AES_DOUTR: u32,
        }), base_address + 0xc);

        /// address: 0x50060010
        /// key register 0
        pub const KEYR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Output Register (LSB key
            /// [31:0])
            AES_KEYR0: u32,
        }), base_address + 0x10);

        /// address: 0x50060014
        /// key register 1
        pub const KEYR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// AES key register (key
            /// [63:32])
            AES_KEYR1: u32,
        }), base_address + 0x14);

        /// address: 0x50060018
        /// key register 2
        pub const KEYR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// AES key register (key
            /// [95:64])
            AES_KEYR2: u32,
        }), base_address + 0x18);

        /// address: 0x5006001c
        /// key register 3
        pub const KEYR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// AES key register (MSB key
            /// [127:96])
            AES_KEYR3: u32,
        }), base_address + 0x1c);

        /// address: 0x50060020
        /// initialization vector register
        /// 0
        pub const IVR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// initialization vector register (LSB IVR
            /// [31:0])
            AES_IVR0: u32,
        }), base_address + 0x20);

        /// address: 0x50060024
        /// initialization vector register
        /// 1
        pub const IVR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initialization Vector Register (IVR
            /// [63:32])
            AES_IVR1: u32,
        }), base_address + 0x24);

        /// address: 0x50060028
        /// initialization vector register
        /// 2
        pub const IVR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initialization Vector Register (IVR
            /// [95:64])
            AES_IVR2: u32,
        }), base_address + 0x28);

        /// address: 0x5006002c
        /// initialization vector register
        /// 3
        pub const IVR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initialization Vector Register (MSB IVR
            /// [127:96])
            AES_IVR3: u32,
        }), base_address + 0x2c);
    };

    /// Analog-to-Digital Converter
    pub const ADC1 = struct {
        pub const base_address = 0x50040000;

        /// address: 0x50040000
        /// interrupt and status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDY
            ADRDY: u1,
            /// EOSMP
            EOSMP: u1,
            /// EOC
            EOC: u1,
            /// EOS
            EOS: u1,
            /// OVR
            OVR: u1,
            /// JEOC
            JEOC: u1,
            /// JEOS
            JEOS: u1,
            /// AWD1
            AWD1: u1,
            /// AWD2
            AWD2: u1,
            /// AWD3
            AWD3: u1,
            /// JQOVF
            JQOVF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x0);

        /// address: 0x50040004
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDYIE
            ADRDYIE: u1,
            /// EOSMPIE
            EOSMPIE: u1,
            /// EOCIE
            EOCIE: u1,
            /// EOSIE
            EOSIE: u1,
            /// OVRIE
            OVRIE: u1,
            /// JEOCIE
            JEOCIE: u1,
            /// JEOSIE
            JEOSIE: u1,
            /// AWD1IE
            AWD1IE: u1,
            /// AWD2IE
            AWD2IE: u1,
            /// AWD3IE
            AWD3IE: u1,
            /// JQOVFIE
            JQOVFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x4);

        /// address: 0x50040008
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADEN
            ADEN: u1,
            /// ADDIS
            ADDIS: u1,
            /// ADSTART
            ADSTART: u1,
            /// JADSTART
            JADSTART: u1,
            /// ADSTP
            ADSTP: u1,
            /// JADSTP
            JADSTP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// ADVREGEN
            ADVREGEN: u1,
            /// DEEPPWD
            DEEPPWD: u1,
            /// ADCALDIF
            ADCALDIF: u1,
            /// ADCAL
            ADCAL: u1,
        }), base_address + 0x8);

        /// address: 0x5004000c
        /// configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAEN
            DMAEN: u1,
            /// DMACFG
            DMACFG: u1,
            reserved0: u1,
            /// RES
            RES: u2,
            /// ALIGN
            ALIGN: u1,
            /// EXTSEL
            EXTSEL: u4,
            /// EXTEN
            EXTEN: u2,
            /// OVRMOD
            OVRMOD: u1,
            /// CONT
            CONT: u1,
            /// AUTDLY
            AUTDLY: u1,
            reserved1: u1,
            /// DISCEN
            DISCEN: u1,
            /// DISCNUM
            DISCNUM: u3,
            /// JDISCEN
            JDISCEN: u1,
            /// JQM
            JQM: u1,
            /// AWD1SGL
            AWD1SGL: u1,
            /// AWD1EN
            AWD1EN: u1,
            /// JAWD1EN
            JAWD1EN: u1,
            /// JAUTO
            JAUTO: u1,
            /// AWDCH1CH
            AWDCH1CH: u5,
            /// JQDIS
            JQDIS: u1,
        }), base_address + 0xc);

        /// address: 0x50040010
        /// configuration register
        pub const CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAEN
            ROVSE: u1,
            /// DMACFG
            JOVSE: u1,
            /// RES
            OVSR: u3,
            /// ALIGN
            OVSS: u4,
            /// EXTSEL
            TOVS: u1,
            /// EXTEN
            ROVSM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x50040014
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMP0
            SMP0: u3,
            /// SMP1
            SMP1: u3,
            /// SMP2
            SMP2: u3,
            /// SMP3
            SMP3: u3,
            /// SMP4
            SMP4: u3,
            /// SMP5
            SMP5: u3,
            /// SMP6
            SMP6: u3,
            /// SMP7
            SMP7: u3,
            /// SMP8
            SMP8: u3,
            /// SMP9
            SMP9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x50040018
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMP10
            SMP10: u3,
            /// SMP11
            SMP11: u3,
            /// SMP12
            SMP12: u3,
            /// SMP13
            SMP13: u3,
            /// SMP14
            SMP14: u3,
            /// SMP15
            SMP15: u3,
            /// SMP16
            SMP16: u3,
            /// SMP17
            SMP17: u3,
            /// SMP18
            SMP18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x18);

        /// address: 0x50040020
        /// watchdog threshold register 1
        pub const TR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT1
            LT1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// HT1
            HT1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x50040024
        /// watchdog threshold register
        pub const TR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT2
            LT2: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT2
            HT2: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x50040028
        /// watchdog threshold register 3
        pub const TR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT3
            LT3: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT3
            HT3: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x50040030
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L
            L: u4,
            reserved0: u1,
            reserved1: u1,
            /// SQ1
            SQ1: u5,
            reserved2: u1,
            /// SQ2
            SQ2: u5,
            reserved3: u1,
            /// SQ3
            SQ3: u5,
            reserved4: u1,
            /// SQ4
            SQ4: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x30);

        /// address: 0x50040034
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ5
            SQ5: u5,
            reserved0: u1,
            /// SQ6
            SQ6: u5,
            reserved1: u1,
            /// SQ7
            SQ7: u5,
            reserved2: u1,
            /// SQ8
            SQ8: u5,
            reserved3: u1,
            /// SQ9
            SQ9: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x34);

        /// address: 0x50040038
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ10
            SQ10: u5,
            reserved0: u1,
            /// SQ11
            SQ11: u5,
            reserved1: u1,
            /// SQ12
            SQ12: u5,
            reserved2: u1,
            /// SQ13
            SQ13: u5,
            reserved3: u1,
            /// SQ14
            SQ14: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x38);

        /// address: 0x5004003c
        /// regular sequence register 4
        pub const SQR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ15
            SQ15: u5,
            reserved0: u1,
            /// SQ16
            SQ16: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x3c);

        /// address: 0x50040040
        /// regular Data Register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// regularDATA
            regularDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x5004004c
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// JL
            JL: u2,
            /// JEXTSEL
            JEXTSEL: u4,
            /// JEXTEN
            JEXTEN: u2,
            /// JSQ1
            JSQ1: u5,
            reserved0: u1,
            /// JSQ2
            JSQ2: u5,
            reserved1: u1,
            /// JSQ3
            JSQ3: u5,
            reserved2: u1,
            /// JSQ4
            JSQ4: u5,
            padding0: u1,
        }), base_address + 0x4c);

        /// address: 0x50040060
        /// offset register 1
        pub const OFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET1
            OFFSET1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET1_CH
            OFFSET1_CH: u5,
            /// OFFSET1_EN
            OFFSET1_EN: u1,
        }), base_address + 0x60);

        /// address: 0x50040064
        /// offset register 2
        pub const OFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET2
            OFFSET2: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET2_CH
            OFFSET2_CH: u5,
            /// OFFSET2_EN
            OFFSET2_EN: u1,
        }), base_address + 0x64);

        /// address: 0x50040068
        /// offset register 3
        pub const OFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET3
            OFFSET3: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET3_CH
            OFFSET3_CH: u5,
            /// OFFSET3_EN
            OFFSET3_EN: u1,
        }), base_address + 0x68);

        /// address: 0x5004006c
        /// offset register 4
        pub const OFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET4
            OFFSET4: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET4_CH
            OFFSET4_CH: u5,
            /// OFFSET4_EN
            OFFSET4_EN: u1,
        }), base_address + 0x6c);

        /// address: 0x50040080
        /// injected data register 1
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA1
            JDATA1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x50040084
        /// injected data register 2
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA2
            JDATA2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x50040088
        /// injected data register 3
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA3
            JDATA3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x5004008c
        /// injected data register 4
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA4
            JDATA4: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x500400a0
        /// Analog Watchdog 2 Configuration
        /// Register
        pub const AWD2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AWD2CH
            AWD2CH: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x500400a4
        /// Analog Watchdog 3 Configuration
        /// Register
        pub const AWD3CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AWD3CH
            AWD3CH: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa4);

        /// address: 0x500400b0
        /// Differential Mode Selection Register
        /// 2
        pub const DIFSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Differential mode for channel
            /// 0
            DIFSEL_0: u1,
            /// Differential mode for channels 15 to
            /// 1
            DIFSEL_1_15: u15,
            /// Differential mode for channels 18 to
            /// 16
            DIFSEL_16_18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xb0);

        /// address: 0x500400b4
        /// Calibration Factors
        pub const CALFACT = @intToPtr(*volatile Mmio(32, packed struct {
            /// CALFACT_S
            CALFACT_S: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// CALFACT_D
            CALFACT_D: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xb4);
    };
    pub const ADC2 = struct {
        pub const base_address = 0x50040100;

        /// address: 0x50040100
        /// interrupt and status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDY
            ADRDY: u1,
            /// EOSMP
            EOSMP: u1,
            /// EOC
            EOC: u1,
            /// EOS
            EOS: u1,
            /// OVR
            OVR: u1,
            /// JEOC
            JEOC: u1,
            /// JEOS
            JEOS: u1,
            /// AWD1
            AWD1: u1,
            /// AWD2
            AWD2: u1,
            /// AWD3
            AWD3: u1,
            /// JQOVF
            JQOVF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x0);

        /// address: 0x50040104
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDYIE
            ADRDYIE: u1,
            /// EOSMPIE
            EOSMPIE: u1,
            /// EOCIE
            EOCIE: u1,
            /// EOSIE
            EOSIE: u1,
            /// OVRIE
            OVRIE: u1,
            /// JEOCIE
            JEOCIE: u1,
            /// JEOSIE
            JEOSIE: u1,
            /// AWD1IE
            AWD1IE: u1,
            /// AWD2IE
            AWD2IE: u1,
            /// AWD3IE
            AWD3IE: u1,
            /// JQOVFIE
            JQOVFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x4);

        /// address: 0x50040108
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADEN
            ADEN: u1,
            /// ADDIS
            ADDIS: u1,
            /// ADSTART
            ADSTART: u1,
            /// JADSTART
            JADSTART: u1,
            /// ADSTP
            ADSTP: u1,
            /// JADSTP
            JADSTP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// ADVREGEN
            ADVREGEN: u1,
            /// DEEPPWD
            DEEPPWD: u1,
            /// ADCALDIF
            ADCALDIF: u1,
            /// ADCAL
            ADCAL: u1,
        }), base_address + 0x8);

        /// address: 0x5004010c
        /// configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAEN
            DMAEN: u1,
            /// DMACFG
            DMACFG: u1,
            reserved0: u1,
            /// RES
            RES: u2,
            /// ALIGN
            ALIGN: u1,
            /// EXTSEL
            EXTSEL: u4,
            /// EXTEN
            EXTEN: u2,
            /// OVRMOD
            OVRMOD: u1,
            /// CONT
            CONT: u1,
            /// AUTDLY
            AUTDLY: u1,
            reserved1: u1,
            /// DISCEN
            DISCEN: u1,
            /// DISCNUM
            DISCNUM: u3,
            /// JDISCEN
            JDISCEN: u1,
            /// JQM
            JQM: u1,
            /// AWD1SGL
            AWD1SGL: u1,
            /// AWD1EN
            AWD1EN: u1,
            /// JAWD1EN
            JAWD1EN: u1,
            /// JAUTO
            JAUTO: u1,
            /// AWDCH1CH
            AWDCH1CH: u5,
            /// JQDIS
            JQDIS: u1,
        }), base_address + 0xc);

        /// address: 0x50040110
        /// configuration register
        pub const CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAEN
            ROVSE: u1,
            /// DMACFG
            JOVSE: u1,
            /// RES
            OVSR: u3,
            /// ALIGN
            OVSS: u4,
            /// EXTSEL
            TOVS: u1,
            /// EXTEN
            ROVSM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x50040114
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMP0
            SMP0: u3,
            /// SMP1
            SMP1: u3,
            /// SMP2
            SMP2: u3,
            /// SMP3
            SMP3: u3,
            /// SMP4
            SMP4: u3,
            /// SMP5
            SMP5: u3,
            /// SMP6
            SMP6: u3,
            /// SMP7
            SMP7: u3,
            /// SMP8
            SMP8: u3,
            /// SMP9
            SMP9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x50040118
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMP10
            SMP10: u3,
            /// SMP11
            SMP11: u3,
            /// SMP12
            SMP12: u3,
            /// SMP13
            SMP13: u3,
            /// SMP14
            SMP14: u3,
            /// SMP15
            SMP15: u3,
            /// SMP16
            SMP16: u3,
            /// SMP17
            SMP17: u3,
            /// SMP18
            SMP18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x18);

        /// address: 0x50040120
        /// watchdog threshold register 1
        pub const TR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT1
            LT1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// HT1
            HT1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x50040124
        /// watchdog threshold register
        pub const TR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT2
            LT2: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT2
            HT2: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x50040128
        /// watchdog threshold register 3
        pub const TR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT3
            LT3: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT3
            HT3: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x50040130
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L
            L: u4,
            reserved0: u1,
            reserved1: u1,
            /// SQ1
            SQ1: u5,
            reserved2: u1,
            /// SQ2
            SQ2: u5,
            reserved3: u1,
            /// SQ3
            SQ3: u5,
            reserved4: u1,
            /// SQ4
            SQ4: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x30);

        /// address: 0x50040134
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ5
            SQ5: u5,
            reserved0: u1,
            /// SQ6
            SQ6: u5,
            reserved1: u1,
            /// SQ7
            SQ7: u5,
            reserved2: u1,
            /// SQ8
            SQ8: u5,
            reserved3: u1,
            /// SQ9
            SQ9: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x34);

        /// address: 0x50040138
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ10
            SQ10: u5,
            reserved0: u1,
            /// SQ11
            SQ11: u5,
            reserved1: u1,
            /// SQ12
            SQ12: u5,
            reserved2: u1,
            /// SQ13
            SQ13: u5,
            reserved3: u1,
            /// SQ14
            SQ14: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x38);

        /// address: 0x5004013c
        /// regular sequence register 4
        pub const SQR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ15
            SQ15: u5,
            reserved0: u1,
            /// SQ16
            SQ16: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x3c);

        /// address: 0x50040140
        /// regular Data Register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// regularDATA
            regularDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x5004014c
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// JL
            JL: u2,
            /// JEXTSEL
            JEXTSEL: u4,
            /// JEXTEN
            JEXTEN: u2,
            /// JSQ1
            JSQ1: u5,
            reserved0: u1,
            /// JSQ2
            JSQ2: u5,
            reserved1: u1,
            /// JSQ3
            JSQ3: u5,
            reserved2: u1,
            /// JSQ4
            JSQ4: u5,
            padding0: u1,
        }), base_address + 0x4c);

        /// address: 0x50040160
        /// offset register 1
        pub const OFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET1
            OFFSET1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET1_CH
            OFFSET1_CH: u5,
            /// OFFSET1_EN
            OFFSET1_EN: u1,
        }), base_address + 0x60);

        /// address: 0x50040164
        /// offset register 2
        pub const OFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET2
            OFFSET2: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET2_CH
            OFFSET2_CH: u5,
            /// OFFSET2_EN
            OFFSET2_EN: u1,
        }), base_address + 0x64);

        /// address: 0x50040168
        /// offset register 3
        pub const OFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET3
            OFFSET3: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET3_CH
            OFFSET3_CH: u5,
            /// OFFSET3_EN
            OFFSET3_EN: u1,
        }), base_address + 0x68);

        /// address: 0x5004016c
        /// offset register 4
        pub const OFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET4
            OFFSET4: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET4_CH
            OFFSET4_CH: u5,
            /// OFFSET4_EN
            OFFSET4_EN: u1,
        }), base_address + 0x6c);

        /// address: 0x50040180
        /// injected data register 1
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA1
            JDATA1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x50040184
        /// injected data register 2
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA2
            JDATA2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x50040188
        /// injected data register 3
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA3
            JDATA3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x5004018c
        /// injected data register 4
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA4
            JDATA4: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x500401a0
        /// Analog Watchdog 2 Configuration
        /// Register
        pub const AWD2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AWD2CH
            AWD2CH: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x500401a4
        /// Analog Watchdog 3 Configuration
        /// Register
        pub const AWD3CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AWD3CH
            AWD3CH: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa4);

        /// address: 0x500401b0
        /// Differential Mode Selection Register
        /// 2
        pub const DIFSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Differential mode for channel
            /// 0
            DIFSEL_0: u1,
            /// Differential mode for channels 15 to
            /// 1
            DIFSEL_1_15: u15,
            /// Differential mode for channels 18 to
            /// 16
            DIFSEL_16_18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xb0);

        /// address: 0x500401b4
        /// Calibration Factors
        pub const CALFACT = @intToPtr(*volatile Mmio(32, packed struct {
            /// CALFACT_S
            CALFACT_S: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// CALFACT_D
            CALFACT_D: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xb4);
    };
    pub const ADC3 = struct {
        pub const base_address = 0x50040200;

        /// address: 0x50040200
        /// interrupt and status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDY
            ADRDY: u1,
            /// EOSMP
            EOSMP: u1,
            /// EOC
            EOC: u1,
            /// EOS
            EOS: u1,
            /// OVR
            OVR: u1,
            /// JEOC
            JEOC: u1,
            /// JEOS
            JEOS: u1,
            /// AWD1
            AWD1: u1,
            /// AWD2
            AWD2: u1,
            /// AWD3
            AWD3: u1,
            /// JQOVF
            JQOVF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x0);

        /// address: 0x50040204
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADRDYIE
            ADRDYIE: u1,
            /// EOSMPIE
            EOSMPIE: u1,
            /// EOCIE
            EOCIE: u1,
            /// EOSIE
            EOSIE: u1,
            /// OVRIE
            OVRIE: u1,
            /// JEOCIE
            JEOCIE: u1,
            /// JEOSIE
            JEOSIE: u1,
            /// AWD1IE
            AWD1IE: u1,
            /// AWD2IE
            AWD2IE: u1,
            /// AWD3IE
            AWD3IE: u1,
            /// JQOVFIE
            JQOVFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x4);

        /// address: 0x50040208
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADEN
            ADEN: u1,
            /// ADDIS
            ADDIS: u1,
            /// ADSTART
            ADSTART: u1,
            /// JADSTART
            JADSTART: u1,
            /// ADSTP
            ADSTP: u1,
            /// JADSTP
            JADSTP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            /// ADVREGEN
            ADVREGEN: u1,
            /// DEEPPWD
            DEEPPWD: u1,
            /// ADCALDIF
            ADCALDIF: u1,
            /// ADCAL
            ADCAL: u1,
        }), base_address + 0x8);

        /// address: 0x5004020c
        /// configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAEN
            DMAEN: u1,
            /// DMACFG
            DMACFG: u1,
            reserved0: u1,
            /// RES
            RES: u2,
            /// ALIGN
            ALIGN: u1,
            /// EXTSEL
            EXTSEL: u4,
            /// EXTEN
            EXTEN: u2,
            /// OVRMOD
            OVRMOD: u1,
            /// CONT
            CONT: u1,
            /// AUTDLY
            AUTDLY: u1,
            reserved1: u1,
            /// DISCEN
            DISCEN: u1,
            /// DISCNUM
            DISCNUM: u3,
            /// JDISCEN
            JDISCEN: u1,
            /// JQM
            JQM: u1,
            /// AWD1SGL
            AWD1SGL: u1,
            /// AWD1EN
            AWD1EN: u1,
            /// JAWD1EN
            JAWD1EN: u1,
            /// JAUTO
            JAUTO: u1,
            /// AWDCH1CH
            AWDCH1CH: u5,
            /// JQDIS
            JQDIS: u1,
        }), base_address + 0xc);

        /// address: 0x50040210
        /// configuration register
        pub const CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMAEN
            ROVSE: u1,
            /// DMACFG
            JOVSE: u1,
            /// RES
            OVSR: u3,
            /// ALIGN
            OVSS: u4,
            /// EXTSEL
            TOVS: u1,
            /// EXTEN
            ROVSM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x50040214
        /// sample time register 1
        pub const SMPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMP0
            SMP0: u3,
            /// SMP1
            SMP1: u3,
            /// SMP2
            SMP2: u3,
            /// SMP3
            SMP3: u3,
            /// SMP4
            SMP4: u3,
            /// SMP5
            SMP5: u3,
            /// SMP6
            SMP6: u3,
            /// SMP7
            SMP7: u3,
            /// SMP8
            SMP8: u3,
            /// SMP9
            SMP9: u3,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x14);

        /// address: 0x50040218
        /// sample time register 2
        pub const SMPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMP10
            SMP10: u3,
            /// SMP11
            SMP11: u3,
            /// SMP12
            SMP12: u3,
            /// SMP13
            SMP13: u3,
            /// SMP14
            SMP14: u3,
            /// SMP15
            SMP15: u3,
            /// SMP16
            SMP16: u3,
            /// SMP17
            SMP17: u3,
            /// SMP18
            SMP18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x18);

        /// address: 0x50040220
        /// watchdog threshold register 1
        pub const TR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT1
            LT1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// HT1
            HT1: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x50040224
        /// watchdog threshold register
        pub const TR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT2
            LT2: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT2
            HT2: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x50040228
        /// watchdog threshold register 3
        pub const TR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// LT3
            LT3: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HT3
            HT3: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x50040230
        /// regular sequence register 1
        pub const SQR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// L
            L: u4,
            reserved0: u1,
            reserved1: u1,
            /// SQ1
            SQ1: u5,
            reserved2: u1,
            /// SQ2
            SQ2: u5,
            reserved3: u1,
            /// SQ3
            SQ3: u5,
            reserved4: u1,
            /// SQ4
            SQ4: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x30);

        /// address: 0x50040234
        /// regular sequence register 2
        pub const SQR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ5
            SQ5: u5,
            reserved0: u1,
            /// SQ6
            SQ6: u5,
            reserved1: u1,
            /// SQ7
            SQ7: u5,
            reserved2: u1,
            /// SQ8
            SQ8: u5,
            reserved3: u1,
            /// SQ9
            SQ9: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x34);

        /// address: 0x50040238
        /// regular sequence register 3
        pub const SQR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ10
            SQ10: u5,
            reserved0: u1,
            /// SQ11
            SQ11: u5,
            reserved1: u1,
            /// SQ12
            SQ12: u5,
            reserved2: u1,
            /// SQ13
            SQ13: u5,
            reserved3: u1,
            /// SQ14
            SQ14: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x38);

        /// address: 0x5004023c
        /// regular sequence register 4
        pub const SQR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SQ15
            SQ15: u5,
            reserved0: u1,
            /// SQ16
            SQ16: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x3c);

        /// address: 0x50040240
        /// regular Data Register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// regularDATA
            regularDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x5004024c
        /// injected sequence register
        pub const JSQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// JL
            JL: u2,
            /// JEXTSEL
            JEXTSEL: u4,
            /// JEXTEN
            JEXTEN: u2,
            /// JSQ1
            JSQ1: u5,
            reserved0: u1,
            /// JSQ2
            JSQ2: u5,
            reserved1: u1,
            /// JSQ3
            JSQ3: u5,
            reserved2: u1,
            /// JSQ4
            JSQ4: u5,
            padding0: u1,
        }), base_address + 0x4c);

        /// address: 0x50040260
        /// offset register 1
        pub const OFR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET1
            OFFSET1: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET1_CH
            OFFSET1_CH: u5,
            /// OFFSET1_EN
            OFFSET1_EN: u1,
        }), base_address + 0x60);

        /// address: 0x50040264
        /// offset register 2
        pub const OFR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET2
            OFFSET2: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET2_CH
            OFFSET2_CH: u5,
            /// OFFSET2_EN
            OFFSET2_EN: u1,
        }), base_address + 0x64);

        /// address: 0x50040268
        /// offset register 3
        pub const OFR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET3
            OFFSET3: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET3_CH
            OFFSET3_CH: u5,
            /// OFFSET3_EN
            OFFSET3_EN: u1,
        }), base_address + 0x68);

        /// address: 0x5004026c
        /// offset register 4
        pub const OFR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// OFFSET4
            OFFSET4: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// OFFSET4_CH
            OFFSET4_CH: u5,
            /// OFFSET4_EN
            OFFSET4_EN: u1,
        }), base_address + 0x6c);

        /// address: 0x50040280
        /// injected data register 1
        pub const JDR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA1
            JDATA1: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x50040284
        /// injected data register 2
        pub const JDR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA2
            JDATA2: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x50040288
        /// injected data register 3
        pub const JDR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA3
            JDATA3: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x88);

        /// address: 0x5004028c
        /// injected data register 4
        pub const JDR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// JDATA4
            JDATA4: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x500402a0
        /// Analog Watchdog 2 Configuration
        /// Register
        pub const AWD2CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AWD2CH
            AWD2CH: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa0);

        /// address: 0x500402a4
        /// Analog Watchdog 3 Configuration
        /// Register
        pub const AWD3CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AWD3CH
            AWD3CH: u19,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xa4);

        /// address: 0x500402b0
        /// Differential Mode Selection Register
        /// 2
        pub const DIFSEL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Differential mode for channel
            /// 0
            DIFSEL_0: u1,
            /// Differential mode for channels 15 to
            /// 1
            DIFSEL_1_15: u15,
            /// Differential mode for channels 18 to
            /// 16
            DIFSEL_16_18: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xb0);

        /// address: 0x500402b4
        /// Calibration Factors
        pub const CALFACT = @intToPtr(*volatile Mmio(32, packed struct {
            /// CALFACT_S
            CALFACT_S: u7,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// CALFACT_D
            CALFACT_D: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xb4);
    };

    /// Analog-to-Digital Converter
    pub const ADC123_Common = struct {
        pub const base_address = 0x50040300;

        /// address: 0x50040300
        /// ADC Common status register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADDRDY_MST
            ADDRDY_MST: u1,
            /// EOSMP_MST
            EOSMP_MST: u1,
            /// EOC_MST
            EOC_MST: u1,
            /// EOS_MST
            EOS_MST: u1,
            /// OVR_MST
            OVR_MST: u1,
            /// JEOC_MST
            JEOC_MST: u1,
            /// JEOS_MST
            JEOS_MST: u1,
            /// AWD1_MST
            AWD1_MST: u1,
            /// AWD2_MST
            AWD2_MST: u1,
            /// AWD3_MST
            AWD3_MST: u1,
            /// JQOVF_MST
            JQOVF_MST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// ADRDY_SLV
            ADRDY_SLV: u1,
            /// EOSMP_SLV
            EOSMP_SLV: u1,
            /// End of regular conversion of the slave
            /// ADC
            EOC_SLV: u1,
            /// End of regular sequence flag of the
            /// slave ADC
            EOS_SLV: u1,
            /// Overrun flag of the slave
            /// ADC
            OVR_SLV: u1,
            /// End of injected conversion flag of the
            /// slave ADC
            JEOC_SLV: u1,
            /// End of injected sequence flag of the
            /// slave ADC
            JEOS_SLV: u1,
            /// Analog watchdog 1 flag of the slave
            /// ADC
            AWD1_SLV: u1,
            /// Analog watchdog 2 flag of the slave
            /// ADC
            AWD2_SLV: u1,
            /// Analog watchdog 3 flag of the slave
            /// ADC
            AWD3_SLV: u1,
            /// Injected Context Queue Overflow flag of
            /// the slave ADC
            JQOVF_SLV: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x0);

        /// address: 0x50040308
        /// ADC common control register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dual ADC mode selection
            DUAL: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Delay between 2 sampling
            /// phases
            DELAY: u4,
            reserved3: u1,
            /// DMA configuration (for multi-ADC
            /// mode)
            DMACFG: u1,
            /// Direct memory access mode for multi ADC
            /// mode
            MDMA: u2,
            /// ADC clock mode
            CKMODE: u2,
            /// ADC prescaler
            PRESC: u4,
            /// VREFINT enable
            VREFEN: u1,
            /// CH17SEL
            CH17SEL: u1,
            /// CH18SEL
            CH18SEL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x5004030c
        /// ADC common regular data register for dual
        /// and triple modes
        pub const CDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular data of the master
            /// ADC
            RDATA_MST: u16,
            /// Regular data of the slave
            /// ADC
            RDATA_SLV: u16,
        }), base_address + 0xc);
    };

    /// General-purpose I/Os
    pub const GPIOA = struct {
        pub const base_address = 0x48000000;

        /// address: 0x48000000
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48000004
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48000008
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4800000c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48000010
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48000014
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48000018
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4800001c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48000020
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48000024
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);
    };

    /// General-purpose I/Os
    pub const GPIOB = struct {
        pub const base_address = 0x48000400;

        /// address: 0x48000400
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48000404
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48000408
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4800040c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48000410
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48000414
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48000418
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4800041c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48000420
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48000424
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);
    };

    /// General-purpose I/Os
    pub const GPIOC = struct {
        pub const base_address = 0x48000800;

        /// address: 0x48000800
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48000804
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48000808
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4800080c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48000810
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48000814
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48000818
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4800081c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48000820
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48000824
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);
    };
    pub const GPIOD = struct {
        pub const base_address = 0x48000c00;

        /// address: 0x48000c00
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48000c04
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48000c08
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x48000c0c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48000c10
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48000c14
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48000c18
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x48000c1c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48000c20
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48000c24
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);
    };
    pub const GPIOE = struct {
        pub const base_address = 0x48001000;

        /// address: 0x48001000
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48001004
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48001008
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x4800100c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48001010
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48001014
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48001018
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x4800101c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48001020
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48001024
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);
    };
    pub const GPIOH = struct {
        pub const base_address = 0x48001c00;

        /// address: 0x48001c00
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODER0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODER15: u2,
        }), base_address + 0x0);

        /// address: 0x48001c04
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x48001c08
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEEDR15: u2,
        }), base_address + 0x8);

        /// address: 0x48001c0c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPDR15: u2,
        }), base_address + 0xc);

        /// address: 0x48001c10
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data (y =
            /// 0..15)
            IDR0: u1,
            /// Port input data (y =
            /// 0..15)
            IDR1: u1,
            /// Port input data (y =
            /// 0..15)
            IDR2: u1,
            /// Port input data (y =
            /// 0..15)
            IDR3: u1,
            /// Port input data (y =
            /// 0..15)
            IDR4: u1,
            /// Port input data (y =
            /// 0..15)
            IDR5: u1,
            /// Port input data (y =
            /// 0..15)
            IDR6: u1,
            /// Port input data (y =
            /// 0..15)
            IDR7: u1,
            /// Port input data (y =
            /// 0..15)
            IDR8: u1,
            /// Port input data (y =
            /// 0..15)
            IDR9: u1,
            /// Port input data (y =
            /// 0..15)
            IDR10: u1,
            /// Port input data (y =
            /// 0..15)
            IDR11: u1,
            /// Port input data (y =
            /// 0..15)
            IDR12: u1,
            /// Port input data (y =
            /// 0..15)
            IDR13: u1,
            /// Port input data (y =
            /// 0..15)
            IDR14: u1,
            /// Port input data (y =
            /// 0..15)
            IDR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x48001c14
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data (y =
            /// 0..15)
            ODR0: u1,
            /// Port output data (y =
            /// 0..15)
            ODR1: u1,
            /// Port output data (y =
            /// 0..15)
            ODR2: u1,
            /// Port output data (y =
            /// 0..15)
            ODR3: u1,
            /// Port output data (y =
            /// 0..15)
            ODR4: u1,
            /// Port output data (y =
            /// 0..15)
            ODR5: u1,
            /// Port output data (y =
            /// 0..15)
            ODR6: u1,
            /// Port output data (y =
            /// 0..15)
            ODR7: u1,
            /// Port output data (y =
            /// 0..15)
            ODR8: u1,
            /// Port output data (y =
            /// 0..15)
            ODR9: u1,
            /// Port output data (y =
            /// 0..15)
            ODR10: u1,
            /// Port output data (y =
            /// 0..15)
            ODR11: u1,
            /// Port output data (y =
            /// 0..15)
            ODR12: u1,
            /// Port output data (y =
            /// 0..15)
            ODR13: u1,
            /// Port output data (y =
            /// 0..15)
            ODR14: u1,
            /// Port output data (y =
            /// 0..15)
            ODR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x48001c18
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x48001c1c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x48001c20
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL0: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL1: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL2: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL3: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL4: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL5: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL6: u4,
            /// Alternate function selection for port x
            /// bit y (y = 0..7)
            AFRL7: u4,
        }), base_address + 0x20);

        /// address: 0x48001c24
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH8: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH9: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH10: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH11: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH12: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH13: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH14: u4,
            /// Alternate function selection for port x
            /// bit y (y = 8..15)
            AFRH15: u4,
        }), base_address + 0x24);
    };

    /// Serial audio interface
    pub const SAI1 = struct {
        pub const base_address = 0x40015400;

        /// address: 0x40015424
        /// BConfiguration register 1
        pub const BCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Audio block mode
            MODE: u2,
            /// Protocol configuration
            PRTCFG: u2,
            reserved0: u1,
            /// Data size
            DS: u3,
            /// Least significant bit
            /// first
            LSBFIRST: u1,
            /// Clock strobing edge
            CKSTR: u1,
            /// Synchronization enable
            SYNCEN: u2,
            /// Mono mode
            MONO: u1,
            /// Output drive
            OutDri: u1,
            reserved1: u1,
            reserved2: u1,
            /// Audio block B enable
            SAIBEN: u1,
            /// DMA enable
            DMAEN: u1,
            reserved3: u1,
            /// No divider
            NODIV: u1,
            /// Master clock divider
            MCKDIV: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x24);

        /// address: 0x40015428
        /// BConfiguration register 2
        pub const BCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold
            FTH: u3,
            /// FIFO flush
            FFLUS: u1,
            /// Tristate management on data
            /// line
            TRIS: u1,
            /// Mute
            MUTE: u1,
            /// Mute value
            MUTEVAL: u1,
            /// Mute counter
            MUTECN: u6,
            /// Complement bit
            CPL: u1,
            /// Companding mode
            COMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4001542c
        /// BFRCR
        pub const BFRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame length
            FRL: u8,
            /// Frame synchronization active level
            /// length
            FSALL: u7,
            reserved0: u1,
            /// Frame synchronization
            /// definition
            FSDEF: u1,
            /// Frame synchronization
            /// polarity
            FSPOL: u1,
            /// Frame synchronization
            /// offset
            FSOFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x2c);

        /// address: 0x40015430
        /// BSlot register
        pub const BSLOTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// First bit offset
            FBOFF: u5,
            reserved0: u1,
            /// Slot size
            SLOTSZ: u2,
            /// Number of slots in an audio
            /// frame
            NBSLOT: u4,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Slot enable
            SLOTEN: u16,
        }), base_address + 0x30);

        /// address: 0x40015434
        /// BInterrupt mask register2
        pub const BIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun/underrun interrupt
            /// enable
            OVRUDRIE: u1,
            /// Mute detection interrupt
            /// enable
            MUTEDET: u1,
            /// Wrong clock configuration interrupt
            /// enable
            WCKCFG: u1,
            /// FIFO request interrupt
            /// enable
            FREQIE: u1,
            /// Codec not ready interrupt
            /// enable
            CNRDYIE: u1,
            /// Anticipated frame synchronization
            /// detection interrupt enable
            AFSDETIE: u1,
            /// Late frame synchronization detection
            /// interrupt enable
            LFSDETIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x34);

        /// address: 0x40015438
        /// BStatus register
        pub const BSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun / underrun
            OVRUDR: u1,
            /// Mute detection
            MUTEDET: u1,
            /// Wrong clock configuration
            /// flag
            WCKCFG: u1,
            /// FIFO request
            FREQ: u1,
            /// Codec not ready
            CNRDY: u1,
            /// Anticipated frame synchronization
            /// detection
            AFSDET: u1,
            /// Late frame synchronization
            /// detection
            LFSDET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// FIFO level threshold
            FLVL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x38);

        /// address: 0x4001543c
        /// BClear flag register
        pub const BCLRFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear overrun / underrun
            OVRUDR: u1,
            /// Mute detection flag
            MUTEDET: u1,
            /// Clear wrong clock configuration
            /// flag
            WCKCFG: u1,
            reserved0: u1,
            /// Clear codec not ready flag
            CNRDY: u1,
            /// Clear anticipated frame synchronization
            /// detection flag
            CAFSDET: u1,
            /// Clear late frame synchronization
            /// detection flag
            LFSDET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x3c);

        /// address: 0x40015440
        /// BData register
        pub const BDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data
            DATA: u32,
        }), base_address + 0x40);

        /// address: 0x40015404
        /// AConfiguration register 1
        pub const ACR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Audio block mode
            MODE: u2,
            /// Protocol configuration
            PRTCFG: u2,
            reserved0: u1,
            /// Data size
            DS: u3,
            /// Least significant bit
            /// first
            LSBFIRST: u1,
            /// Clock strobing edge
            CKSTR: u1,
            /// Synchronization enable
            SYNCEN: u2,
            /// Mono mode
            MONO: u1,
            /// Output drive
            OutDri: u1,
            reserved1: u1,
            reserved2: u1,
            /// Audio block A enable
            SAIAEN: u1,
            /// DMA enable
            DMAEN: u1,
            reserved3: u1,
            /// No divider
            NODIV: u1,
            /// Master clock divider
            MCKDIV: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40015408
        /// AConfiguration register 2
        pub const ACR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// FIFO threshold
            FTH: u3,
            /// FIFO flush
            FFLUS: u1,
            /// Tristate management on data
            /// line
            TRIS: u1,
            /// Mute
            MUTE: u1,
            /// Mute value
            MUTEVAL: u1,
            /// Mute counter
            MUTECN: u6,
            /// Complement bit
            CPL: u1,
            /// Companding mode
            COMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001540c
        /// AFRCR
        pub const AFRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame length
            FRL: u8,
            /// Frame synchronization active level
            /// length
            FSALL: u7,
            reserved0: u1,
            /// Frame synchronization
            /// definition
            FSDEF: u1,
            /// Frame synchronization
            /// polarity
            FSPOL: u1,
            /// Frame synchronization
            /// offset
            FSOFF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0xc);

        /// address: 0x40015410
        /// ASlot register
        pub const ASLOTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// First bit offset
            FBOFF: u5,
            reserved0: u1,
            /// Slot size
            SLOTSZ: u2,
            /// Number of slots in an audio
            /// frame
            NBSLOT: u4,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Slot enable
            SLOTEN: u16,
        }), base_address + 0x10);

        /// address: 0x40015414
        /// AInterrupt mask register2
        pub const AIM = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun/underrun interrupt
            /// enable
            OVRUDRIE: u1,
            /// Mute detection interrupt
            /// enable
            MUTEDET: u1,
            /// Wrong clock configuration interrupt
            /// enable
            WCKCFG: u1,
            /// FIFO request interrupt
            /// enable
            FREQIE: u1,
            /// Codec not ready interrupt
            /// enable
            CNRDYIE: u1,
            /// Anticipated frame synchronization
            /// detection interrupt enable
            AFSDETIE: u1,
            /// Late frame synchronization detection
            /// interrupt enable
            LFSDET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40015418
        /// AStatus register
        pub const ASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Overrun / underrun
            OVRUDR: u1,
            /// Mute detection
            MUTEDET: u1,
            /// Wrong clock configuration flag. This bit
            /// is read only
            WCKCFG: u1,
            /// FIFO request
            FREQ: u1,
            /// Codec not ready
            CNRDY: u1,
            /// Anticipated frame synchronization
            /// detection
            AFSDET: u1,
            /// Late frame synchronization
            /// detection
            LFSDET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// FIFO level threshold
            FLVL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x18);

        /// address: 0x4001541c
        /// AClear flag register
        pub const ACLRFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear overrun / underrun
            OVRUDR: u1,
            /// Mute detection flag
            MUTEDET: u1,
            /// Clear wrong clock configuration
            /// flag
            WCKCFG: u1,
            reserved0: u1,
            /// Clear codec not ready flag
            CNRDY: u1,
            /// Clear anticipated frame synchronization
            /// detection flag
            CAFSDET: u1,
            /// Clear late frame synchronization
            /// detection flag
            LFSDET: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x1c);

        /// address: 0x40015420
        /// AData register
        pub const ADR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data
            DATA: u32,
        }), base_address + 0x20);
    };

    /// General-purpose-timers
    pub const TIM2 = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000000c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000018
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000024
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16,
            /// High counter value (TIM2
            /// only)
            CNT_H: u16,
        }), base_address + 0x24);

        /// address: 0x40000028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000002c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16,
            /// High Auto-reload value (TIM2
            /// only)
            ARR_H: u16,
        }), base_address + 0x2c);

        /// address: 0x40000034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1_L: u16,
            /// High Capture/Compare 1 value (TIM2
            /// only)
            CCR1_H: u16,
        }), base_address + 0x34);

        /// address: 0x40000038
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2_L: u16,
            /// High Capture/Compare 2 value (TIM2
            /// only)
            CCR2_H: u16,
        }), base_address + 0x38);

        /// address: 0x4000003c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR3_H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000040
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR4_H: u16,
        }), base_address + 0x40);

        /// address: 0x40000048
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000004c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40000050
        /// TIM2 option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer2 ETR remap
            ETR_RMP: u3,
            /// Internal trigger
            TI4_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x50);
    };
    pub const TIM3 = struct {
        pub const base_address = 0x40000400;

        /// address: 0x40000400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000040c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000418
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000424
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16,
            /// High counter value (TIM2
            /// only)
            CNT_H: u16,
        }), base_address + 0x24);

        /// address: 0x40000428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000042c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16,
            /// High Auto-reload value (TIM2
            /// only)
            ARR_H: u16,
        }), base_address + 0x2c);

        /// address: 0x40000434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1_L: u16,
            /// High Capture/Compare 1 value (TIM2
            /// only)
            CCR1_H: u16,
        }), base_address + 0x34);

        /// address: 0x40000438
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2_L: u16,
            /// High Capture/Compare 2 value (TIM2
            /// only)
            CCR2_H: u16,
        }), base_address + 0x38);

        /// address: 0x4000043c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR3_H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000440
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR4_H: u16,
        }), base_address + 0x40);

        /// address: 0x40000448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000044c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40000450
        /// TIM2 option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer2 ETR remap
            ETR_RMP: u3,
            /// Internal trigger
            TI4_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x50);
    };

    /// General purpose timers
    pub const TIM15 = struct {
        pub const base_address = 0x40014000;

        /// address: 0x40014000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved3: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40014004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x4001400c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40014010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved3: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40014014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40014018
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Output Compare 1 mode
            OC1M_2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);

        /// address: 0x40014018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40014020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40014024
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF Copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40014028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001402c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014030
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40014034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014044
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x44);

        /// address: 0x40014048
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001404c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40014038
        /// TIM15 capture/compare register
        /// 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x40014050
        /// TIM15 option register 1
        pub const OR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input capture 1 remap
            TI1_RMP: u1,
            /// Encoder mode
            ENCODER_MODE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x50);

        /// address: 0x40014060
        /// TIM15 option register 2
        pub const OR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1,
            /// BRK COMP1 enable
            BKCMP1E: u1,
            /// BRK COMP2 enable
            BKCMP2E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// BRK BKIN input polarity
            BKINP: u1,
            /// BRK COMP1 input polarity
            BKCMP1P: u1,
            /// BRK COMP2 input polarity
            BKCMP2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x60);

        /// address: 0x40014008
        /// TIM15 slave mode control
        /// register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SMS
            SMS: u3,
            reserved0: u1,
            /// TS
            TS: u3,
            /// MSM
            MSM: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// SMS bit 16
            SMS_16: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x8);
    };

    /// General purpose timers
    pub const TIM16 = struct {
        pub const base_address = 0x40014400;

        /// address: 0x40014400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            reserved3: u1,
            /// UIF status bit remapping
            UIFREMAP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40014404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x4001440c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40014410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved3: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x10);

        /// address: 0x40014414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40014418
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Output Compare 1 mode
            OC1M_2: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x18);

        /// address: 0x40014418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x18);

        /// address: 0x40014420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x20);

        /// address: 0x40014424
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// counter value
            CNT: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// UIF Copy
            UIFCPY: u1,
        }), base_address + 0x24);

        /// address: 0x40014428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001442c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40014430
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40014434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40014444
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            /// Break filter
            BKF: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x44);

        /// address: 0x40014448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4001444c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40014450
        /// TIM16 option register 1
        pub const OR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Input capture 1 remap
            TI1_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x50);

        /// address: 0x40014460
        /// TIM17 option register 1
        pub const OR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1,
            /// BRK COMP1 enable
            BKCMP1E: u1,
            /// BRK COMP2 enable
            BKCMP2E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// BRK DFSDM_BREAK1 enable
            BKDFBK1E: u1,
            /// BRK BKIN input polarity
            BKINP: u1,
            /// BRK COMP1 input polarity
            BKCMP1P: u1,
            /// BRK COMP2 input polarit
            BKCMP2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x60);
    };

    /// Advanced-timers
    pub const TIM1 = struct {
        pub const base_address = 0x40012c00;

        /// address: 0x40012c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40012c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare preloaded
            /// control
            CCPC: u1,
            reserved0: u1,
            /// Capture/compare control update
            /// selection
            CCUS: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            /// Output Idle state 1
            OIS1: u1,
            /// Output Idle state 1
            OIS1N: u1,
            /// Output Idle state 2
            OIS2: u1,
            /// Output Idle state 2
            OIS2N: u1,
            /// Output Idle state 3
            OIS3: u1,
            /// Output Idle state 3
            OIS3N: u1,
            /// Output Idle state 4
            OIS4: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40012c08
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40012c0c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            /// COM interrupt enable
            COMIE: u1,
            /// Trigger interrupt enable
            TIE: u1,
            /// Break interrupt enable
            BIE: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            /// COM DMA request enable
            COMDE: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40012c10
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            /// COM interrupt flag
            COMIF: u1,
            /// Trigger interrupt flag
            TIF: u1,
            /// Break interrupt flag
            BIF: u1,
            reserved0: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40012c14
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            /// Capture/Compare control update
            /// generation
            COMG: u1,
            /// Trigger generation
            TG: u1,
            /// Break generation
            BG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x14);

        /// address: 0x40012c18
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            /// Output Compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            /// Output Compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40012c18
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            ICPCS: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PCS: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40012c1c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40012c1c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40012c20
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            /// Capture/Compare 1 complementary output
            /// enable
            CC1NE: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            /// Capture/Compare 2 complementary output
            /// enable
            CC2NE: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            /// Capture/Compare 3 complementary output
            /// enable
            CC3NE: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20);

        /// address: 0x40012c24
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40012c28
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x40012c2c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40012c30
        /// repetition counter register
        pub const RCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Repetition counter value
            REP: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x30);

        /// address: 0x40012c34
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40012c38
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x40012c3c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x3c);

        /// address: 0x40012c40
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x40);

        /// address: 0x40012c44
        /// break and dead-time register
        pub const BDTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Dead-time generator setup
            DTG: u8,
            /// Lock configuration
            LOCK: u2,
            /// Off-state selection for Idle
            /// mode
            OSSI: u1,
            /// Off-state selection for Run
            /// mode
            OSSR: u1,
            /// Break enable
            BKE: u1,
            /// Break polarity
            BKP: u1,
            /// Automatic output enable
            AOE: u1,
            /// Main output enable
            MOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40012c48
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x40012c4c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40012c50
        /// DMA address for full transfer
        pub const OR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// External trigger remap on ADC1 analog
            /// watchdog
            ETR_ADC1_RMP: u2,
            /// External trigger remap on ADC3 analog
            /// watchdog
            ETR_ADC3_RMP: u2,
            /// Input Capture 1 remap
            TI1_RMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x50);

        /// address: 0x40012c54
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR3_Output = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Output compare 5 fast
            /// enable
            OC5FE: u1,
            /// Output compare 5 preload
            /// enable
            OC5PE: u1,
            /// Output compare 5 mode
            OC5M: u3,
            /// Output compare 5 clear
            /// enable
            OC5CE: u1,
            reserved2: u1,
            reserved3: u1,
            /// Output compare 6 fast
            /// enable
            OC6FE: u1,
            /// Output compare 6 preload
            /// enable
            OC6PE: u1,
            /// Output compare 6 mode
            OC6M: u3,
            /// Output compare 6 clear
            /// enable
            OC6CE: u1,
            /// Output Compare 5 mode bit
            /// 3
            OC5M_bit3: u3,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Output Compare 6 mode bit
            /// 3
            OC6M_bit3: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x54);

        /// address: 0x40012c58
        /// capture/compare register 4
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare value
            CCR5: u16,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// Group Channel 5 and Channel
            /// 1
            GC5C1: u1,
            /// Group Channel 5 and Channel
            /// 2
            GC5C2: u1,
            /// Group Channel 5 and Channel
            /// 3
            GC5C3: u1,
        }), base_address + 0x58);

        /// address: 0x40012c5c
        /// capture/compare register 4
        pub const CCR6 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x5c);

        /// address: 0x40012c60
        /// DMA address for full transfer
        pub const OR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK BKIN input enable
            BKINE: u1,
            /// BRK COMP1 enable
            BKCMP1E: u1,
            /// BRK COMP2 enable
            BKCMP2E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// BRK DFSDM_BREAK0 enable
            BKDFBK0E: u1,
            /// BRK BKIN input polarity
            BKINP: u1,
            /// BRK COMP1 input polarity
            BKCMP1P: u1,
            /// BRK COMP2 input polarity
            BKCMP2P: u1,
            reserved5: u1,
            reserved6: u1,
            /// ETR source selection
            ETRSEL: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x60);

        /// address: 0x40012c64
        /// DMA address for full transfer
        pub const OR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRK2 BKIN input enable
            BK2INE: u1,
            /// BRK2 COMP1 enable
            BK2CMP1E: u1,
            /// BRK2 COMP2 enable
            BK2CMP2E: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// BRK2 DFSDM_BREAK0 enable
            BK2DFBK0E: u1,
            /// BRK2 BKIN input polarity
            BK2INP: u1,
            /// BRK2 COMP1 input polarity
            BK2CMP1P: u1,
            /// BRK2 COMP2 input polarity
            BK2CMP2P: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x64);
    };

    /// Basic-timers
    pub const TIM6 = struct {
        pub const base_address = 0x40001000;

        /// address: 0x40001000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40001004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000100c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x40001010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x40001014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x40001024
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000102c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);
    };
    pub const TIM7 = struct {
        pub const base_address = 0x40001400;

        /// address: 0x40001400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40001404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000140c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x40001410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x40001414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x40001424
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000142c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);
    };

    /// Low power timer
    pub const LPTIM1 = struct {
        pub const base_address = 0x40007c00;

        /// address: 0x40007c00
        /// Interrupt and Status Register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compare match
            CMPM: u1,
            /// Autoreload match
            ARRM: u1,
            /// External trigger edge
            /// event
            EXTTRIG: u1,
            /// Compare register update OK
            CMPOK: u1,
            /// Autoreload register update
            /// OK
            ARROK: u1,
            /// Counter direction change down to
            /// up
            UP: u1,
            /// Counter direction change up to
            /// down
            DOWN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x0);

        /// address: 0x40007c04
        /// Interrupt Clear Register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// compare match Clear Flag
            CMPMCF: u1,
            /// Autoreload match Clear
            /// Flag
            ARRMCF: u1,
            /// External trigger valid edge Clear
            /// Flag
            EXTTRIGCF: u1,
            /// Compare register update OK Clear
            /// Flag
            CMPOKCF: u1,
            /// Autoreload register update OK Clear
            /// Flag
            ARROKCF: u1,
            /// Direction change to UP Clear
            /// Flag
            UPCF: u1,
            /// Direction change to down Clear
            /// Flag
            DOWNCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40007c08
        /// Interrupt Enable Register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compare match Interrupt
            /// Enable
            CMPMIE: u1,
            /// Autoreload match Interrupt
            /// Enable
            ARRMIE: u1,
            /// External trigger valid edge Interrupt
            /// Enable
            EXTTRIGIE: u1,
            /// Compare register update OK Interrupt
            /// Enable
            CMPOKIE: u1,
            /// Autoreload register update OK Interrupt
            /// Enable
            ARROKIE: u1,
            /// Direction change to UP Interrupt
            /// Enable
            UPIE: u1,
            /// Direction change to down Interrupt
            /// Enable
            DOWNIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x8);

        /// address: 0x40007c0c
        /// Configuration Register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock selector
            CKSEL: u1,
            /// Clock Polarity
            CKPOL: u2,
            /// Configurable digital filter for external
            /// clock
            CKFLT: u2,
            reserved0: u1,
            /// Configurable digital filter for
            /// trigger
            TRGFLT: u2,
            reserved1: u1,
            /// Clock prescaler
            PRESC: u3,
            reserved2: u1,
            /// Trigger selector
            TRIGSEL: u3,
            reserved3: u1,
            /// Trigger enable and
            /// polarity
            TRIGEN: u2,
            /// Timeout enable
            TIMOUT: u1,
            /// Waveform shape
            WAVE: u1,
            /// Waveform shape polarity
            WAVPOL: u1,
            /// Registers update mode
            PRELOAD: u1,
            /// counter mode enabled
            COUNTMODE: u1,
            /// Encoder mode enable
            ENC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xc);

        /// address: 0x40007c10
        /// Control Register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LPTIM Enable
            ENABLE: u1,
            /// LPTIM start in single mode
            SNGSTRT: u1,
            /// Timer start in continuous
            /// mode
            CNTSTRT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x10);

        /// address: 0x40007c14
        /// Compare Register
        pub const CMP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x14);

        /// address: 0x40007c18
        /// Autoreload Register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x18);

        /// address: 0x40007c1c
        /// Counter Register
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x1c);
    };
    pub const LPTIM2 = struct {
        pub const base_address = 0x40009400;

        /// address: 0x40009400
        /// Interrupt and Status Register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compare match
            CMPM: u1,
            /// Autoreload match
            ARRM: u1,
            /// External trigger edge
            /// event
            EXTTRIG: u1,
            /// Compare register update OK
            CMPOK: u1,
            /// Autoreload register update
            /// OK
            ARROK: u1,
            /// Counter direction change down to
            /// up
            UP: u1,
            /// Counter direction change up to
            /// down
            DOWN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x0);

        /// address: 0x40009404
        /// Interrupt Clear Register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// compare match Clear Flag
            CMPMCF: u1,
            /// Autoreload match Clear
            /// Flag
            ARRMCF: u1,
            /// External trigger valid edge Clear
            /// Flag
            EXTTRIGCF: u1,
            /// Compare register update OK Clear
            /// Flag
            CMPOKCF: u1,
            /// Autoreload register update OK Clear
            /// Flag
            ARROKCF: u1,
            /// Direction change to UP Clear
            /// Flag
            UPCF: u1,
            /// Direction change to down Clear
            /// Flag
            DOWNCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40009408
        /// Interrupt Enable Register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compare match Interrupt
            /// Enable
            CMPMIE: u1,
            /// Autoreload match Interrupt
            /// Enable
            ARRMIE: u1,
            /// External trigger valid edge Interrupt
            /// Enable
            EXTTRIGIE: u1,
            /// Compare register update OK Interrupt
            /// Enable
            CMPOKIE: u1,
            /// Autoreload register update OK Interrupt
            /// Enable
            ARROKIE: u1,
            /// Direction change to UP Interrupt
            /// Enable
            UPIE: u1,
            /// Direction change to down Interrupt
            /// Enable
            DOWNIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x8);

        /// address: 0x4000940c
        /// Configuration Register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock selector
            CKSEL: u1,
            /// Clock Polarity
            CKPOL: u2,
            /// Configurable digital filter for external
            /// clock
            CKFLT: u2,
            reserved0: u1,
            /// Configurable digital filter for
            /// trigger
            TRGFLT: u2,
            reserved1: u1,
            /// Clock prescaler
            PRESC: u3,
            reserved2: u1,
            /// Trigger selector
            TRIGSEL: u3,
            reserved3: u1,
            /// Trigger enable and
            /// polarity
            TRIGEN: u2,
            /// Timeout enable
            TIMOUT: u1,
            /// Waveform shape
            WAVE: u1,
            /// Waveform shape polarity
            WAVPOL: u1,
            /// Registers update mode
            PRELOAD: u1,
            /// counter mode enabled
            COUNTMODE: u1,
            /// Encoder mode enable
            ENC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xc);

        /// address: 0x40009410
        /// Control Register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LPTIM Enable
            ENABLE: u1,
            /// LPTIM start in single mode
            SNGSTRT: u1,
            /// Timer start in continuous
            /// mode
            CNTSTRT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x10);

        /// address: 0x40009414
        /// Compare Register
        pub const CMP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x14);

        /// address: 0x40009418
        /// Autoreload Register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x18);

        /// address: 0x4000941c
        /// Counter Register
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x1c);
    };

    /// Universal synchronous asynchronous receiver
    /// transmitter
    pub const USART1 = struct {
        pub const base_address = 0x40013800;

        /// address: 0x40013800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40013804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40013808
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4001380c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40013810
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013814
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40013818
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4001381c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40013820
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40013824
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40013828
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const USART2 = struct {
        pub const base_address = 0x40004400;

        /// address: 0x40004400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40004404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40004408
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000440c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004410
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004414
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004418
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000441c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004420
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004424
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004428
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const UART4 = struct {
        pub const base_address = 0x40004c00;

        /// address: 0x40004c00
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40004c04
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40004c08
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x40004c0c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004c10
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004c14
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004c18
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x40004c1c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004c20
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004c24
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004c28
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };

    /// Universal synchronous asynchronous receiver
    /// transmitter
    pub const USART3 = struct {
        pub const base_address = 0x40004800;

        /// address: 0x40004800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40004804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40004808
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            /// USART Clock Enable in Stop
            /// mode
            UCESM: u1,
            /// Transmission complete before guard time
            /// interrupt enable
            TCBGTIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x4000480c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile MmioInt(32, u12), base_address + 0xc);

        /// address: 0x40004810
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004814
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004818
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000481c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            reserved1: u1,
            reserved2: u1,
            /// Transmission complete before guard time
            /// completion
            TCBGT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x1c);

        /// address: 0x40004820
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004824
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004828
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };

    /// Universal synchronous asynchronous receiver
    /// transmitter
    pub const LPUART1 = struct {
        pub const base_address = 0x40008000;

        /// address: 0x40008000
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            reserved0: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            reserved1: u1,
            reserved2: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40008004
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            reserved10: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40008008
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Half-duplex selection
            HDSEL: u1,
            reserved2: u1,
            reserved3: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            reserved4: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000800c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile MmioInt(32, u20), base_address + 0xc);

        /// address: 0x40008018
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x18);

        /// address: 0x4000801c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            reserved0: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40008020
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            reserved2: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved10: u1,
            reserved11: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40008024
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40008028
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };

    /// Serial peripheral interface/Inter-IC
    /// sound
    pub const SPI1 = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// Data frame format
            DFF: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40013004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40013008
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            reserved0: u1,
            reserved1: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4001300c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40013010
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013014
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40013018
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);
    };
    pub const SPI3 = struct {
        pub const base_address = 0x40003c00;

        /// address: 0x40003c00
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// Data frame format
            DFF: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003c04
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40003c08
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            reserved0: u1,
            reserved1: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x40003c0c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003c10
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003c14
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003c18
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);
    };
    pub const SPI2 = struct {
        pub const base_address = 0x40003800;

        /// address: 0x40003800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// Data frame format
            DFF: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            /// NSS pulse management
            NSSP: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            /// Data size
            DS: u4,
            /// FIFO reception threshold
            FRXTH: u1,
            /// Last DMA transfer for
            /// reception
            LDMA_RX: u1,
            /// Last DMA transfer for
            /// transmission
            LDMA_TX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40003808
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            reserved0: u1,
            reserved1: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            /// FIFO reception level
            FRLVL: u2,
            /// FIFO transmission level
            FTLVL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x4000380c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003810
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003814
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003818
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);
    };

    /// Secure digital input/output
    /// interface
    pub const SDMMC = struct {
        pub const base_address = 0x40012800;

        /// address: 0x40012800
        /// power control register
        pub const POWER = @intToPtr(*volatile Mmio(32, packed struct {
            /// PWRCTRL
            PWRCTRL: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x0);

        /// address: 0x40012804
        /// SDI clock control register
        pub const CLKCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock divide factor
            CLKDIV: u8,
            /// Clock enable bit
            CLKEN: u1,
            /// Power saving configuration
            /// bit
            PWRSAV: u1,
            /// Clock divider bypass enable
            /// bit
            BYPASS: u1,
            /// Wide bus mode enable bit
            WIDBUS: u2,
            /// SDIO_CK dephasing selection
            /// bit
            NEGEDGE: u1,
            /// HW Flow Control enable
            HWFC_EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x4);

        /// address: 0x40012808
        /// argument register
        pub const ARG = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command argument
            CMDARG: u32,
        }), base_address + 0x8);

        /// address: 0x4001280c
        /// command register
        pub const CMD = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command index
            CMDINDEX: u6,
            /// Wait for response bits
            WAITRESP: u2,
            /// CPSM waits for interrupt
            /// request
            WAITINT: u1,
            /// CPSM Waits for ends of data transfer
            /// (CmdPend internal signal)
            WAITPEND: u1,
            /// Command path state machine (CPSM) Enable
            /// bit
            CPSMEN: u1,
            /// SD I/O suspend command
            SDIOSuspend: u1,
            /// Enable CMD completion
            ENCMDcompl: u1,
            /// not Interrupt Enable
            nIEN: u1,
            /// CE-ATA command
            CE_ATACMD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40012810
        /// command response register
        pub const RESPCMD = @intToPtr(*volatile MmioInt(32, u6), base_address + 0x10);

        /// address: 0x40012814
        /// response 1..4 register
        pub const RESP1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS1: u32,
        }), base_address + 0x14);

        /// address: 0x40012818
        /// response 1..4 register
        pub const RESP2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS2: u32,
        }), base_address + 0x18);

        /// address: 0x4001281c
        /// response 1..4 register
        pub const RESP3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS3: u32,
        }), base_address + 0x1c);

        /// address: 0x40012820
        /// response 1..4 register
        pub const RESP4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// see Table 132
            CARDSTATUS4: u32,
        }), base_address + 0x20);

        /// address: 0x40012824
        /// data timer register
        pub const DTIMER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data timeout period
            DATATIME: u32,
        }), base_address + 0x24);

        /// address: 0x40012828
        /// data length register
        pub const DLEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length value
            DATALENGTH: u25,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x28);

        /// address: 0x4001282c
        /// data control register
        pub const DCTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DTEN
            DTEN: u1,
            /// Data transfer direction
            /// selection
            DTDIR: u1,
            /// Data transfer mode selection 1: Stream
            /// or SDIO multibyte data transfer
            DTMODE: u1,
            /// DMA enable bit
            DMAEN: u1,
            /// Data block size
            DBLOCKSIZE: u4,
            /// Read wait start
            RWSTART: u1,
            /// Read wait stop
            RWSTOP: u1,
            /// Read wait mode
            RWMOD: u1,
            /// SD I/O enable functions
            SDIOEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x2c);

        /// address: 0x40012830
        /// data counter register
        pub const DCOUNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data count value
            DATACOUNT: u25,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x30);

        /// address: 0x40012834
        /// status register
        pub const STA = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command response received (CRC check
            /// failed)
            CCRCFAIL: u1,
            /// Data block sent/received (CRC check
            /// failed)
            DCRCFAIL: u1,
            /// Command response timeout
            CTIMEOUT: u1,
            /// Data timeout
            DTIMEOUT: u1,
            /// Transmit FIFO underrun
            /// error
            TXUNDERR: u1,
            /// Received FIFO overrun
            /// error
            RXOVERR: u1,
            /// Command response received (CRC check
            /// passed)
            CMDREND: u1,
            /// Command sent (no response
            /// required)
            CMDSENT: u1,
            /// Data end (data counter, SDIDCOUNT, is
            /// zero)
            DATAEND: u1,
            /// Start bit not detected on all data
            /// signals in wide bus mode
            STBITERR: u1,
            /// Data block sent/received (CRC check
            /// passed)
            DBCKEND: u1,
            /// Command transfer in
            /// progress
            CMDACT: u1,
            /// Data transmit in progress
            TXACT: u1,
            /// Data receive in progress
            RXACT: u1,
            /// Transmit FIFO half empty: at least 8
            /// words can be written into the FIFO
            TXFIFOHE: u1,
            /// Receive FIFO half full: there are at
            /// least 8 words in the FIFO
            RXFIFOHF: u1,
            /// Transmit FIFO full
            TXFIFOF: u1,
            /// Receive FIFO full
            RXFIFOF: u1,
            /// Transmit FIFO empty
            TXFIFOE: u1,
            /// Receive FIFO empty
            RXFIFOE: u1,
            /// Data available in transmit
            /// FIFO
            TXDAVL: u1,
            /// Data available in receive
            /// FIFO
            RXDAVL: u1,
            /// SDIO interrupt received
            SDIOIT: u1,
            /// CE-ATA command completion signal
            /// received for CMD61
            CEATAEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x34);

        /// address: 0x40012838
        /// interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CCRCFAIL flag clear bit
            CCRCFAILC: u1,
            /// DCRCFAIL flag clear bit
            DCRCFAILC: u1,
            /// CTIMEOUT flag clear bit
            CTIMEOUTC: u1,
            /// DTIMEOUT flag clear bit
            DTIMEOUTC: u1,
            /// TXUNDERR flag clear bit
            TXUNDERRC: u1,
            /// RXOVERR flag clear bit
            RXOVERRC: u1,
            /// CMDREND flag clear bit
            CMDRENDC: u1,
            /// CMDSENT flag clear bit
            CMDSENTC: u1,
            /// DATAEND flag clear bit
            DATAENDC: u1,
            /// STBITERR flag clear bit
            STBITERRC: u1,
            /// DBCKEND flag clear bit
            DBCKENDC: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// SDIOIT flag clear bit
            SDIOITC: u1,
            /// CEATAEND flag clear bit
            CEATAENDC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x38);

        /// address: 0x4001283c
        /// mask register
        pub const MASK = @intToPtr(*volatile Mmio(32, packed struct {
            /// Command CRC fail interrupt
            /// enable
            CCRCFAILIE: u1,
            /// Data CRC fail interrupt
            /// enable
            DCRCFAILIE: u1,
            /// Command timeout interrupt
            /// enable
            CTIMEOUTIE: u1,
            /// Data timeout interrupt
            /// enable
            DTIMEOUTIE: u1,
            /// Tx FIFO underrun error interrupt
            /// enable
            TXUNDERRIE: u1,
            /// Rx FIFO overrun error interrupt
            /// enable
            RXOVERRIE: u1,
            /// Command response received interrupt
            /// enable
            CMDRENDIE: u1,
            /// Command sent interrupt
            /// enable
            CMDSENTIE: u1,
            /// Data end interrupt enable
            DATAENDIE: u1,
            /// Start bit error interrupt
            /// enable
            STBITERRIE: u1,
            /// Data block end interrupt
            /// enable
            DBCKENDIE: u1,
            /// Command acting interrupt
            /// enable
            CMDACTIE: u1,
            /// Data transmit acting interrupt
            /// enable
            TXACTIE: u1,
            /// Data receive acting interrupt
            /// enable
            RXACTIE: u1,
            /// Tx FIFO half empty interrupt
            /// enable
            TXFIFOHEIE: u1,
            /// Rx FIFO half full interrupt
            /// enable
            RXFIFOHFIE: u1,
            /// Tx FIFO full interrupt
            /// enable
            TXFIFOFIE: u1,
            /// Rx FIFO full interrupt
            /// enable
            RXFIFOFIE: u1,
            /// Tx FIFO empty interrupt
            /// enable
            TXFIFOEIE: u1,
            /// Rx FIFO empty interrupt
            /// enable
            RXFIFOEIE: u1,
            /// Data available in Tx FIFO interrupt
            /// enable
            TXDAVLIE: u1,
            /// Data available in Rx FIFO interrupt
            /// enable
            RXDAVLIE: u1,
            /// SDIO mode interrupt received interrupt
            /// enable
            SDIOITIE: u1,
            /// CE-ATA command completion signal
            /// received interrupt enable
            CEATAENDIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x3c);

        /// address: 0x40012848
        /// FIFO counter register
        pub const FIFOCNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Remaining number of words to be written
            /// to or read from the FIFO
            FIFOCOUNT: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x48);

        /// address: 0x40012880
        /// data FIFO register
        pub const FIFO = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive and transmit FIFO
            /// data
            FIFOData: u32,
        }), base_address + 0x80);
    };

    /// External interrupt/event
    /// controller
    pub const EXTI = struct {
        pub const base_address = 0x40010400;

        /// address: 0x40010400
        /// Interrupt mask register
        pub const IMR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt Mask on line 0
            MR0: u1,
            /// Interrupt Mask on line 1
            MR1: u1,
            /// Interrupt Mask on line 2
            MR2: u1,
            /// Interrupt Mask on line 3
            MR3: u1,
            /// Interrupt Mask on line 4
            MR4: u1,
            /// Interrupt Mask on line 5
            MR5: u1,
            /// Interrupt Mask on line 6
            MR6: u1,
            /// Interrupt Mask on line 7
            MR7: u1,
            /// Interrupt Mask on line 8
            MR8: u1,
            /// Interrupt Mask on line 9
            MR9: u1,
            /// Interrupt Mask on line 10
            MR10: u1,
            /// Interrupt Mask on line 11
            MR11: u1,
            /// Interrupt Mask on line 12
            MR12: u1,
            /// Interrupt Mask on line 13
            MR13: u1,
            /// Interrupt Mask on line 14
            MR14: u1,
            /// Interrupt Mask on line 15
            MR15: u1,
            /// Interrupt Mask on line 16
            MR16: u1,
            /// Interrupt Mask on line 17
            MR17: u1,
            /// Interrupt Mask on line 18
            MR18: u1,
            /// Interrupt Mask on line 19
            MR19: u1,
            /// Interrupt Mask on line 20
            MR20: u1,
            /// Interrupt Mask on line 21
            MR21: u1,
            /// Interrupt Mask on line 22
            MR22: u1,
            /// Interrupt Mask on line 23
            MR23: u1,
            /// Interrupt Mask on line 24
            MR24: u1,
            /// Interrupt Mask on line 25
            MR25: u1,
            /// Interrupt Mask on line 26
            MR26: u1,
            /// Interrupt Mask on line 27
            MR27: u1,
            /// Interrupt Mask on line 28
            MR28: u1,
            /// Interrupt Mask on line 29
            MR29: u1,
            /// Interrupt Mask on line 30
            MR30: u1,
            /// Interrupt Mask on line 31
            MR31: u1,
        }), base_address + 0x0);

        /// address: 0x40010404
        /// Event mask register
        pub const EMR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event Mask on line 0
            MR0: u1,
            /// Event Mask on line 1
            MR1: u1,
            /// Event Mask on line 2
            MR2: u1,
            /// Event Mask on line 3
            MR3: u1,
            /// Event Mask on line 4
            MR4: u1,
            /// Event Mask on line 5
            MR5: u1,
            /// Event Mask on line 6
            MR6: u1,
            /// Event Mask on line 7
            MR7: u1,
            /// Event Mask on line 8
            MR8: u1,
            /// Event Mask on line 9
            MR9: u1,
            /// Event Mask on line 10
            MR10: u1,
            /// Event Mask on line 11
            MR11: u1,
            /// Event Mask on line 12
            MR12: u1,
            /// Event Mask on line 13
            MR13: u1,
            /// Event Mask on line 14
            MR14: u1,
            /// Event Mask on line 15
            MR15: u1,
            /// Event Mask on line 16
            MR16: u1,
            /// Event Mask on line 17
            MR17: u1,
            /// Event Mask on line 18
            MR18: u1,
            /// Event Mask on line 19
            MR19: u1,
            /// Event Mask on line 20
            MR20: u1,
            /// Event Mask on line 21
            MR21: u1,
            /// Event Mask on line 22
            MR22: u1,
            /// Event Mask on line 23
            MR23: u1,
            /// Event Mask on line 24
            MR24: u1,
            /// Event Mask on line 25
            MR25: u1,
            /// Event Mask on line 26
            MR26: u1,
            /// Event Mask on line 27
            MR27: u1,
            /// Event Mask on line 28
            MR28: u1,
            /// Event Mask on line 29
            MR29: u1,
            /// Event Mask on line 30
            MR30: u1,
            /// Event Mask on line 31
            MR31: u1,
        }), base_address + 0x4);

        /// address: 0x40010408
        /// Rising Trigger selection
        /// register
        pub const RTSR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rising trigger event configuration of
            /// line 0
            TR0: u1,
            /// Rising trigger event configuration of
            /// line 1
            TR1: u1,
            /// Rising trigger event configuration of
            /// line 2
            TR2: u1,
            /// Rising trigger event configuration of
            /// line 3
            TR3: u1,
            /// Rising trigger event configuration of
            /// line 4
            TR4: u1,
            /// Rising trigger event configuration of
            /// line 5
            TR5: u1,
            /// Rising trigger event configuration of
            /// line 6
            TR6: u1,
            /// Rising trigger event configuration of
            /// line 7
            TR7: u1,
            /// Rising trigger event configuration of
            /// line 8
            TR8: u1,
            /// Rising trigger event configuration of
            /// line 9
            TR9: u1,
            /// Rising trigger event configuration of
            /// line 10
            TR10: u1,
            /// Rising trigger event configuration of
            /// line 11
            TR11: u1,
            /// Rising trigger event configuration of
            /// line 12
            TR12: u1,
            /// Rising trigger event configuration of
            /// line 13
            TR13: u1,
            /// Rising trigger event configuration of
            /// line 14
            TR14: u1,
            /// Rising trigger event configuration of
            /// line 15
            TR15: u1,
            /// Rising trigger event configuration of
            /// line 16
            TR16: u1,
            reserved0: u1,
            /// Rising trigger event configuration of
            /// line 18
            TR18: u1,
            /// Rising trigger event configuration of
            /// line 19
            TR19: u1,
            /// Rising trigger event configuration of
            /// line 20
            TR20: u1,
            /// Rising trigger event configuration of
            /// line 21
            TR21: u1,
            /// Rising trigger event configuration of
            /// line 22
            TR22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4001040c
        /// Falling Trigger selection
        /// register
        pub const FTSR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Falling trigger event configuration of
            /// line 0
            TR0: u1,
            /// Falling trigger event configuration of
            /// line 1
            TR1: u1,
            /// Falling trigger event configuration of
            /// line 2
            TR2: u1,
            /// Falling trigger event configuration of
            /// line 3
            TR3: u1,
            /// Falling trigger event configuration of
            /// line 4
            TR4: u1,
            /// Falling trigger event configuration of
            /// line 5
            TR5: u1,
            /// Falling trigger event configuration of
            /// line 6
            TR6: u1,
            /// Falling trigger event configuration of
            /// line 7
            TR7: u1,
            /// Falling trigger event configuration of
            /// line 8
            TR8: u1,
            /// Falling trigger event configuration of
            /// line 9
            TR9: u1,
            /// Falling trigger event configuration of
            /// line 10
            TR10: u1,
            /// Falling trigger event configuration of
            /// line 11
            TR11: u1,
            /// Falling trigger event configuration of
            /// line 12
            TR12: u1,
            /// Falling trigger event configuration of
            /// line 13
            TR13: u1,
            /// Falling trigger event configuration of
            /// line 14
            TR14: u1,
            /// Falling trigger event configuration of
            /// line 15
            TR15: u1,
            /// Falling trigger event configuration of
            /// line 16
            TR16: u1,
            reserved0: u1,
            /// Falling trigger event configuration of
            /// line 18
            TR18: u1,
            /// Falling trigger event configuration of
            /// line 19
            TR19: u1,
            /// Falling trigger event configuration of
            /// line 20
            TR20: u1,
            /// Falling trigger event configuration of
            /// line 21
            TR21: u1,
            /// Falling trigger event configuration of
            /// line 22
            TR22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xc);

        /// address: 0x40010410
        /// Software interrupt event
        /// register
        pub const SWIER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Interrupt on line
            /// 0
            SWIER0: u1,
            /// Software Interrupt on line
            /// 1
            SWIER1: u1,
            /// Software Interrupt on line
            /// 2
            SWIER2: u1,
            /// Software Interrupt on line
            /// 3
            SWIER3: u1,
            /// Software Interrupt on line
            /// 4
            SWIER4: u1,
            /// Software Interrupt on line
            /// 5
            SWIER5: u1,
            /// Software Interrupt on line
            /// 6
            SWIER6: u1,
            /// Software Interrupt on line
            /// 7
            SWIER7: u1,
            /// Software Interrupt on line
            /// 8
            SWIER8: u1,
            /// Software Interrupt on line
            /// 9
            SWIER9: u1,
            /// Software Interrupt on line
            /// 10
            SWIER10: u1,
            /// Software Interrupt on line
            /// 11
            SWIER11: u1,
            /// Software Interrupt on line
            /// 12
            SWIER12: u1,
            /// Software Interrupt on line
            /// 13
            SWIER13: u1,
            /// Software Interrupt on line
            /// 14
            SWIER14: u1,
            /// Software Interrupt on line
            /// 15
            SWIER15: u1,
            /// Software Interrupt on line
            /// 16
            SWIER16: u1,
            reserved0: u1,
            /// Software Interrupt on line
            /// 18
            SWIER18: u1,
            /// Software Interrupt on line
            /// 19
            SWIER19: u1,
            /// Software Interrupt on line
            /// 20
            SWIER20: u1,
            /// Software Interrupt on line
            /// 21
            SWIER21: u1,
            /// Software Interrupt on line
            /// 22
            SWIER22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x10);

        /// address: 0x40010414
        /// Pending register
        pub const PR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pending bit 0
            PR0: u1,
            /// Pending bit 1
            PR1: u1,
            /// Pending bit 2
            PR2: u1,
            /// Pending bit 3
            PR3: u1,
            /// Pending bit 4
            PR4: u1,
            /// Pending bit 5
            PR5: u1,
            /// Pending bit 6
            PR6: u1,
            /// Pending bit 7
            PR7: u1,
            /// Pending bit 8
            PR8: u1,
            /// Pending bit 9
            PR9: u1,
            /// Pending bit 10
            PR10: u1,
            /// Pending bit 11
            PR11: u1,
            /// Pending bit 12
            PR12: u1,
            /// Pending bit 13
            PR13: u1,
            /// Pending bit 14
            PR14: u1,
            /// Pending bit 15
            PR15: u1,
            /// Pending bit 16
            PR16: u1,
            reserved0: u1,
            /// Pending bit 18
            PR18: u1,
            /// Pending bit 19
            PR19: u1,
            /// Pending bit 20
            PR20: u1,
            /// Pending bit 21
            PR21: u1,
            /// Pending bit 22
            PR22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x14);

        /// address: 0x40010420
        /// Interrupt mask register
        pub const IMR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt Mask on external/internal line
            /// 32
            MR32: u1,
            /// Interrupt Mask on external/internal line
            /// 33
            MR33: u1,
            /// Interrupt Mask on external/internal line
            /// 34
            MR34: u1,
            /// Interrupt Mask on external/internal line
            /// 35
            MR35: u1,
            /// Interrupt Mask on external/internal line
            /// 36
            MR36: u1,
            /// Interrupt Mask on external/internal line
            /// 37
            MR37: u1,
            /// Interrupt Mask on external/internal line
            /// 38
            MR38: u1,
            /// Interrupt Mask on external/internal line
            /// 39
            MR39: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40010424
        /// Event mask register
        pub const EMR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event mask on external/internal line
            /// 32
            MR32: u1,
            /// Event mask on external/internal line
            /// 33
            MR33: u1,
            /// Event mask on external/internal line
            /// 34
            MR34: u1,
            /// Event mask on external/internal line
            /// 35
            MR35: u1,
            /// Event mask on external/internal line
            /// 36
            MR36: u1,
            /// Event mask on external/internal line
            /// 37
            MR37: u1,
            /// Event mask on external/internal line
            /// 38
            MR38: u1,
            /// Event mask on external/internal line
            /// 39
            MR39: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40010428
        /// Rising Trigger selection
        /// register
        pub const RTSR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Rising trigger event configuration bit
            /// of line 35
            RT35: u1,
            /// Rising trigger event configuration bit
            /// of line 36
            RT36: u1,
            /// Rising trigger event configuration bit
            /// of line 37
            RT37: u1,
            /// Rising trigger event configuration bit
            /// of line 38
            RT38: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x28);

        /// address: 0x4001042c
        /// Falling Trigger selection
        /// register
        pub const FTSR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Falling trigger event configuration bit
            /// of line 35
            FT35: u1,
            /// Falling trigger event configuration bit
            /// of line 36
            FT36: u1,
            /// Falling trigger event configuration bit
            /// of line 37
            FT37: u1,
            /// Falling trigger event configuration bit
            /// of line 38
            FT38: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x2c);

        /// address: 0x40010430
        /// Software interrupt event
        /// register
        pub const SWIER2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Software interrupt on line
            /// 35
            SWI35: u1,
            /// Software interrupt on line
            /// 36
            SWI36: u1,
            /// Software interrupt on line
            /// 37
            SWI37: u1,
            /// Software interrupt on line
            /// 38
            SWI38: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x30);

        /// address: 0x40010434
        /// Pending register
        pub const PR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Pending interrupt flag on line
            /// 35
            PIF35: u1,
            /// Pending interrupt flag on line
            /// 36
            PIF36: u1,
            /// Pending interrupt flag on line
            /// 37
            PIF37: u1,
            /// Pending interrupt flag on line
            /// 38
            PIF38: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x34);
    };

    /// Voltage reference buffer
    pub const VREFBUF = struct {
        pub const base_address = 0x40010030;

        /// address: 0x40010030
        /// VREF control and status
        /// register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Voltage reference buffer
            /// enable
            ENVR: u1,
            /// High impedance mode
            HIZ: u1,
            /// Voltage reference scale
            VRS: u1,
            /// Voltage reference buffer
            /// ready
            VRR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x0);

        /// address: 0x40010034
        /// calibration control register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Trimming code
            TRIM: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x4);
    };

    /// Controller area network
    pub const CAN1 = struct {
        pub const base_address = 0x40006400;

        /// address: 0x40006400
        /// master control register
        pub const MCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INRQ
            INRQ: u1,
            /// SLEEP
            SLEEP: u1,
            /// TXFP
            TXFP: u1,
            /// RFLM
            RFLM: u1,
            /// NART
            NART: u1,
            /// AWUM
            AWUM: u1,
            /// ABOM
            ABOM: u1,
            /// TTCM
            TTCM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// RESET
            RESET: u1,
            /// DBF
            DBF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0x40006404
        /// master status register
        pub const MSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INAK
            INAK: u1,
            /// SLAK
            SLAK: u1,
            /// ERRI
            ERRI: u1,
            /// WKUI
            WKUI: u1,
            /// SLAKI
            SLAKI: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// TXM
            TXM: u1,
            /// RXM
            RXM: u1,
            /// SAMP
            SAMP: u1,
            /// RX
            RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x40006408
        /// transmit status register
        pub const TSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RQCP0
            RQCP0: u1,
            /// TXOK0
            TXOK0: u1,
            /// ALST0
            ALST0: u1,
            /// TERR0
            TERR0: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// ABRQ0
            ABRQ0: u1,
            /// RQCP1
            RQCP1: u1,
            /// TXOK1
            TXOK1: u1,
            /// ALST1
            ALST1: u1,
            /// TERR1
            TERR1: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// ABRQ1
            ABRQ1: u1,
            /// RQCP2
            RQCP2: u1,
            /// TXOK2
            TXOK2: u1,
            /// ALST2
            ALST2: u1,
            /// TERR2
            TERR2: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// ABRQ2
            ABRQ2: u1,
            /// CODE
            CODE: u2,
            /// Lowest priority flag for mailbox
            /// 0
            TME0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            TME1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            TME2: u1,
            /// Lowest priority flag for mailbox
            /// 0
            LOW0: u1,
            /// Lowest priority flag for mailbox
            /// 1
            LOW1: u1,
            /// Lowest priority flag for mailbox
            /// 2
            LOW2: u1,
        }), base_address + 0x8);

        /// address: 0x4000640c
        /// receive FIFO 0 register
        pub const RF0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP0
            FMP0: u2,
            reserved0: u1,
            /// FULL0
            FULL0: u1,
            /// FOVR0
            FOVR0: u1,
            /// RFOM0
            RFOM0: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0x40006410
        /// receive FIFO 1 register
        pub const RF1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// FMP1
            FMP1: u2,
            reserved0: u1,
            /// FULL1
            FULL1: u1,
            /// FOVR1
            FOVR1: u1,
            /// RFOM1
            RFOM1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x10);

        /// address: 0x40006414
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// TMEIE
            TMEIE: u1,
            /// FMPIE0
            FMPIE0: u1,
            /// FFIE0
            FFIE0: u1,
            /// FOVIE0
            FOVIE0: u1,
            /// FMPIE1
            FMPIE1: u1,
            /// FFIE1
            FFIE1: u1,
            /// FOVIE1
            FOVIE1: u1,
            reserved0: u1,
            /// EWGIE
            EWGIE: u1,
            /// EPVIE
            EPVIE: u1,
            /// BOFIE
            BOFIE: u1,
            /// LECIE
            LECIE: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// ERRIE
            ERRIE: u1,
            /// WKUIE
            WKUIE: u1,
            /// SLKIE
            SLKIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x14);

        /// address: 0x40006418
        /// interrupt enable register
        pub const ESR = @intToPtr(*volatile Mmio(32, packed struct {
            /// EWGF
            EWGF: u1,
            /// EPVF
            EPVF: u1,
            /// BOFF
            BOFF: u1,
            reserved0: u1,
            /// LEC
            LEC: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// TEC
            TEC: u8,
            /// REC
            REC: u8,
        }), base_address + 0x18);

        /// address: 0x4000641c
        /// bit timing register
        pub const BTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// BRP
            BRP: u10,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// TS1
            TS1: u4,
            /// TS2
            TS2: u3,
            reserved6: u1,
            /// SJW
            SJW: u2,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// LBKM
            LBKM: u1,
            /// SILM
            SILM: u1,
        }), base_address + 0x1c);

        /// address: 0x40006580
        /// TX mailbox identifier register
        pub const TI0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x180);

        /// address: 0x40006584
        /// mailbox data length control and time stamp
        /// register
        pub const TDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x184);

        /// address: 0x40006588
        /// mailbox data low register
        pub const TDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x188);

        /// address: 0x4000658c
        /// mailbox data high register
        pub const TDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x18c);

        /// address: 0x40006590
        /// mailbox identifier register
        pub const TI1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x190);

        /// address: 0x40006594
        /// mailbox data length control and time stamp
        /// register
        pub const TDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x194);

        /// address: 0x40006598
        /// mailbox data low register
        pub const TDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x198);

        /// address: 0x4000659c
        /// mailbox data high register
        pub const TDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x19c);

        /// address: 0x400065a0
        /// mailbox identifier register
        pub const TI2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// TXRQ
            TXRQ: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1a0);

        /// address: 0x400065a4
        /// mailbox data length control and time stamp
        /// register
        pub const TDT2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// TGT
            TGT: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIME
            TIME: u16,
        }), base_address + 0x1a4);

        /// address: 0x400065a8
        /// mailbox data low register
        pub const TDL2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1a8);

        /// address: 0x400065ac
        /// mailbox data high register
        pub const TDH2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1ac);

        /// address: 0x400065b0
        /// receive FIFO mailbox identifier
        /// register
        pub const RI0R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1b0);

        /// address: 0x400065b4
        /// mailbox data high register
        pub const RDT0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1b4);

        /// address: 0x400065b8
        /// mailbox data high register
        pub const RDL0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1b8);

        /// address: 0x400065bc
        /// receive FIFO mailbox data high
        /// register
        pub const RDH0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1bc);

        /// address: 0x400065c0
        /// mailbox data high register
        pub const RI1R = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// RTR
            RTR: u1,
            /// IDE
            IDE: u1,
            /// EXID
            EXID: u18,
            /// STID
            STID: u11,
        }), base_address + 0x1c0);

        /// address: 0x400065c4
        /// mailbox data high register
        pub const RDT1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DLC
            DLC: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// FMI
            FMI: u8,
            /// TIME
            TIME: u16,
        }), base_address + 0x1c4);

        /// address: 0x400065c8
        /// mailbox data high register
        pub const RDL1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA0
            DATA0: u8,
            /// DATA1
            DATA1: u8,
            /// DATA2
            DATA2: u8,
            /// DATA3
            DATA3: u8,
        }), base_address + 0x1c8);

        /// address: 0x400065cc
        /// mailbox data high register
        pub const RDH1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// DATA4
            DATA4: u8,
            /// DATA5
            DATA5: u8,
            /// DATA6
            DATA6: u8,
            /// DATA7
            DATA7: u8,
        }), base_address + 0x1cc);

        /// address: 0x40006600
        /// filter master register
        pub const FMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter initialization mode
            FINIT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x200);

        /// address: 0x40006604
        /// filter mode register
        pub const FM1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter mode
            FBM0: u1,
            /// Filter mode
            FBM1: u1,
            /// Filter mode
            FBM2: u1,
            /// Filter mode
            FBM3: u1,
            /// Filter mode
            FBM4: u1,
            /// Filter mode
            FBM5: u1,
            /// Filter mode
            FBM6: u1,
            /// Filter mode
            FBM7: u1,
            /// Filter mode
            FBM8: u1,
            /// Filter mode
            FBM9: u1,
            /// Filter mode
            FBM10: u1,
            /// Filter mode
            FBM11: u1,
            /// Filter mode
            FBM12: u1,
            /// Filter mode
            FBM13: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x204);

        /// address: 0x4000660c
        /// filter scale register
        pub const FS1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter scale configuration
            FSC0: u1,
            /// Filter scale configuration
            FSC1: u1,
            /// Filter scale configuration
            FSC2: u1,
            /// Filter scale configuration
            FSC3: u1,
            /// Filter scale configuration
            FSC4: u1,
            /// Filter scale configuration
            FSC5: u1,
            /// Filter scale configuration
            FSC6: u1,
            /// Filter scale configuration
            FSC7: u1,
            /// Filter scale configuration
            FSC8: u1,
            /// Filter scale configuration
            FSC9: u1,
            /// Filter scale configuration
            FSC10: u1,
            /// Filter scale configuration
            FSC11: u1,
            /// Filter scale configuration
            FSC12: u1,
            /// Filter scale configuration
            FSC13: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x20c);

        /// address: 0x40006614
        /// filter FIFO assignment
        /// register
        pub const FFA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter FIFO assignment for filter
            /// 0
            FFA0: u1,
            /// Filter FIFO assignment for filter
            /// 1
            FFA1: u1,
            /// Filter FIFO assignment for filter
            /// 2
            FFA2: u1,
            /// Filter FIFO assignment for filter
            /// 3
            FFA3: u1,
            /// Filter FIFO assignment for filter
            /// 4
            FFA4: u1,
            /// Filter FIFO assignment for filter
            /// 5
            FFA5: u1,
            /// Filter FIFO assignment for filter
            /// 6
            FFA6: u1,
            /// Filter FIFO assignment for filter
            /// 7
            FFA7: u1,
            /// Filter FIFO assignment for filter
            /// 8
            FFA8: u1,
            /// Filter FIFO assignment for filter
            /// 9
            FFA9: u1,
            /// Filter FIFO assignment for filter
            /// 10
            FFA10: u1,
            /// Filter FIFO assignment for filter
            /// 11
            FFA11: u1,
            /// Filter FIFO assignment for filter
            /// 12
            FFA12: u1,
            /// Filter FIFO assignment for filter
            /// 13
            FFA13: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x214);

        /// address: 0x4000661c
        /// filter activation register
        pub const FA1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter active
            FACT0: u1,
            /// Filter active
            FACT1: u1,
            /// Filter active
            FACT2: u1,
            /// Filter active
            FACT3: u1,
            /// Filter active
            FACT4: u1,
            /// Filter active
            FACT5: u1,
            /// Filter active
            FACT6: u1,
            /// Filter active
            FACT7: u1,
            /// Filter active
            FACT8: u1,
            /// Filter active
            FACT9: u1,
            /// Filter active
            FACT10: u1,
            /// Filter active
            FACT11: u1,
            /// Filter active
            FACT12: u1,
            /// Filter active
            FACT13: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x21c);

        /// address: 0x40006640
        /// Filter bank 0 register 1
        pub const F0R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x240);

        /// address: 0x40006644
        /// Filter bank 0 register 2
        pub const F0R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x244);

        /// address: 0x40006648
        /// Filter bank 1 register 1
        pub const F1R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x248);

        /// address: 0x4000664c
        /// Filter bank 1 register 2
        pub const F1R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x24c);

        /// address: 0x40006650
        /// Filter bank 2 register 1
        pub const F2R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x250);

        /// address: 0x40006654
        /// Filter bank 2 register 2
        pub const F2R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x254);

        /// address: 0x40006658
        /// Filter bank 3 register 1
        pub const F3R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x258);

        /// address: 0x4000665c
        /// Filter bank 3 register 2
        pub const F3R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x25c);

        /// address: 0x40006660
        /// Filter bank 4 register 1
        pub const F4R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x260);

        /// address: 0x40006664
        /// Filter bank 4 register 2
        pub const F4R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x264);

        /// address: 0x40006668
        /// Filter bank 5 register 1
        pub const F5R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x268);

        /// address: 0x4000666c
        /// Filter bank 5 register 2
        pub const F5R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x26c);

        /// address: 0x40006670
        /// Filter bank 6 register 1
        pub const F6R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x270);

        /// address: 0x40006674
        /// Filter bank 6 register 2
        pub const F6R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x274);

        /// address: 0x40006678
        /// Filter bank 7 register 1
        pub const F7R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x278);

        /// address: 0x4000667c
        /// Filter bank 7 register 2
        pub const F7R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x27c);

        /// address: 0x40006680
        /// Filter bank 8 register 1
        pub const F8R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x280);

        /// address: 0x40006684
        /// Filter bank 8 register 2
        pub const F8R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x284);

        /// address: 0x40006688
        /// Filter bank 9 register 1
        pub const F9R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x288);

        /// address: 0x4000668c
        /// Filter bank 9 register 2
        pub const F9R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x28c);

        /// address: 0x40006690
        /// Filter bank 10 register 1
        pub const F10R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x290);

        /// address: 0x40006694
        /// Filter bank 10 register 2
        pub const F10R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x294);

        /// address: 0x40006698
        /// Filter bank 11 register 1
        pub const F11R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x298);

        /// address: 0x4000669c
        /// Filter bank 11 register 2
        pub const F11R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x29c);

        /// address: 0x400066a0
        /// Filter bank 4 register 1
        pub const F12R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a0);

        /// address: 0x400066a4
        /// Filter bank 12 register 2
        pub const F12R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a4);

        /// address: 0x400066a8
        /// Filter bank 13 register 1
        pub const F13R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2a8);

        /// address: 0x400066ac
        /// Filter bank 13 register 2
        pub const F13R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ac);

        /// address: 0x400066b0
        /// Filter bank 14 register 1
        pub const F14R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b0);

        /// address: 0x400066b4
        /// Filter bank 14 register 2
        pub const F14R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b4);

        /// address: 0x400066b8
        /// Filter bank 15 register 1
        pub const F15R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2b8);

        /// address: 0x400066bc
        /// Filter bank 15 register 2
        pub const F15R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2bc);

        /// address: 0x400066c0
        /// Filter bank 16 register 1
        pub const F16R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c0);

        /// address: 0x400066c4
        /// Filter bank 16 register 2
        pub const F16R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c4);

        /// address: 0x400066c8
        /// Filter bank 17 register 1
        pub const F17R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2c8);

        /// address: 0x400066cc
        /// Filter bank 17 register 2
        pub const F17R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2cc);

        /// address: 0x400066d0
        /// Filter bank 18 register 1
        pub const F18R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d0);

        /// address: 0x400066d4
        /// Filter bank 18 register 2
        pub const F18R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d4);

        /// address: 0x400066d8
        /// Filter bank 19 register 1
        pub const F19R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2d8);

        /// address: 0x400066dc
        /// Filter bank 19 register 2
        pub const F19R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2dc);

        /// address: 0x400066e0
        /// Filter bank 20 register 1
        pub const F20R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e0);

        /// address: 0x400066e4
        /// Filter bank 20 register 2
        pub const F20R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e4);

        /// address: 0x400066e8
        /// Filter bank 21 register 1
        pub const F21R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2e8);

        /// address: 0x400066ec
        /// Filter bank 21 register 2
        pub const F21R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2ec);

        /// address: 0x400066f0
        /// Filter bank 22 register 1
        pub const F22R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f0);

        /// address: 0x400066f4
        /// Filter bank 22 register 2
        pub const F22R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f4);

        /// address: 0x400066f8
        /// Filter bank 23 register 1
        pub const F23R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2f8);

        /// address: 0x400066fc
        /// Filter bank 23 register 2
        pub const F23R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x2fc);

        /// address: 0x40006700
        /// Filter bank 24 register 1
        pub const F24R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x300);

        /// address: 0x40006704
        /// Filter bank 24 register 2
        pub const F24R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x304);

        /// address: 0x40006708
        /// Filter bank 25 register 1
        pub const F25R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x308);

        /// address: 0x4000670c
        /// Filter bank 25 register 2
        pub const F25R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x30c);

        /// address: 0x40006710
        /// Filter bank 26 register 1
        pub const F26R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x310);

        /// address: 0x40006714
        /// Filter bank 26 register 2
        pub const F26R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x314);

        /// address: 0x40006718
        /// Filter bank 27 register 1
        pub const F27R1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x318);

        /// address: 0x4000671c
        /// Filter bank 27 register 2
        pub const F27R2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Filter bits
            FB0: u1,
            /// Filter bits
            FB1: u1,
            /// Filter bits
            FB2: u1,
            /// Filter bits
            FB3: u1,
            /// Filter bits
            FB4: u1,
            /// Filter bits
            FB5: u1,
            /// Filter bits
            FB6: u1,
            /// Filter bits
            FB7: u1,
            /// Filter bits
            FB8: u1,
            /// Filter bits
            FB9: u1,
            /// Filter bits
            FB10: u1,
            /// Filter bits
            FB11: u1,
            /// Filter bits
            FB12: u1,
            /// Filter bits
            FB13: u1,
            /// Filter bits
            FB14: u1,
            /// Filter bits
            FB15: u1,
            /// Filter bits
            FB16: u1,
            /// Filter bits
            FB17: u1,
            /// Filter bits
            FB18: u1,
            /// Filter bits
            FB19: u1,
            /// Filter bits
            FB20: u1,
            /// Filter bits
            FB21: u1,
            /// Filter bits
            FB22: u1,
            /// Filter bits
            FB23: u1,
            /// Filter bits
            FB24: u1,
            /// Filter bits
            FB25: u1,
            /// Filter bits
            FB26: u1,
            /// Filter bits
            FB27: u1,
            /// Filter bits
            FB28: u1,
            /// Filter bits
            FB29: u1,
            /// Filter bits
            FB30: u1,
            /// Filter bits
            FB31: u1,
        }), base_address + 0x31c);
    };

    /// Real-time clock
    pub const RTC = struct {
        pub const base_address = 0x40002800;

        /// address: 0x40002800
        /// time register
        pub const TR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            reserved0: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            reserved1: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x0);

        /// address: 0x40002804
        /// date register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            reserved0: u1,
            reserved1: u1,
            /// Month units in BCD format
            MU: u4,
            /// Month tens in BCD format
            MT: u1,
            /// Week day units
            WDU: u3,
            /// Year units in BCD format
            YU: u4,
            /// Year tens in BCD format
            YT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40002808
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup clock selection
            WCKSEL: u3,
            /// Time-stamp event active
            /// edge
            TSEDGE: u1,
            /// Reference clock detection enable (50 or
            /// 60 Hz)
            REFCKON: u1,
            /// Bypass the shadow
            /// registers
            BYPSHAD: u1,
            /// Hour format
            FMT: u1,
            reserved0: u1,
            /// Alarm A enable
            ALRAE: u1,
            /// Alarm B enable
            ALRBE: u1,
            /// Wakeup timer enable
            WUTE: u1,
            /// Time stamp enable
            TSE: u1,
            /// Alarm A interrupt enable
            ALRAIE: u1,
            /// Alarm B interrupt enable
            ALRBIE: u1,
            /// Wakeup timer interrupt
            /// enable
            WUTIE: u1,
            /// Time-stamp interrupt
            /// enable
            TSIE: u1,
            /// Add 1 hour (summer time
            /// change)
            ADD1H: u1,
            /// Subtract 1 hour (winter time
            /// change)
            SUB1H: u1,
            /// Backup
            BKP: u1,
            /// Calibration output
            /// selection
            COSEL: u1,
            /// Output polarity
            POL: u1,
            /// Output selection
            OSEL: u2,
            /// Calibration output enable
            COE: u1,
            /// timestamp on internal event
            /// enable
            ITSE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x8);

        /// address: 0x4000280c
        /// initialization and status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm A write flag
            ALRAWF: u1,
            /// Alarm B write flag
            ALRBWF: u1,
            /// Wakeup timer write flag
            WUTWF: u1,
            /// Shift operation pending
            SHPF: u1,
            /// Initialization status flag
            INITS: u1,
            /// Registers synchronization
            /// flag
            RSF: u1,
            /// Initialization flag
            INITF: u1,
            /// Initialization mode
            INIT: u1,
            /// Alarm A flag
            ALRAF: u1,
            /// Alarm B flag
            ALRBF: u1,
            /// Wakeup timer flag
            WUTF: u1,
            /// Time-stamp flag
            TSF: u1,
            /// Time-stamp overflow flag
            TSOVF: u1,
            /// Tamper detection flag
            TAMP1F: u1,
            /// RTC_TAMP2 detection flag
            TAMP2F: u1,
            /// RTC_TAMP3 detection flag
            TAMP3F: u1,
            /// Recalibration pending Flag
            RECALPF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0xc);

        /// address: 0x40002810
        /// prescaler register
        pub const PRER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Synchronous prescaler
            /// factor
            PREDIV_S: u15,
            reserved0: u1,
            /// Asynchronous prescaler
            /// factor
            PREDIV_A: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x10);

        /// address: 0x40002814
        /// wakeup timer register
        pub const WUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup auto-reload value
            /// bits
            WUT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x4000281c
        /// alarm A register
        pub const ALRMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            /// Alarm A seconds mask
            MSK1: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            /// Alarm A minutes mask
            MSK2: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            /// Alarm A hours mask
            MSK3: u1,
            /// Date units or day in BCD
            /// format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            /// Week day selection
            WDSEL: u1,
            /// Alarm A date mask
            MSK4: u1,
        }), base_address + 0x1c);

        /// address: 0x40002820
        /// alarm B register
        pub const ALRMBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            /// Alarm B seconds mask
            MSK1: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            /// Alarm B minutes mask
            MSK2: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            /// Alarm B hours mask
            MSK3: u1,
            /// Date units or day in BCD
            /// format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            /// Week day selection
            WDSEL: u1,
            /// Alarm B date mask
            MSK4: u1,
        }), base_address + 0x20);

        /// address: 0x40002824
        /// write protection register
        pub const WPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write protection key
            KEY: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40002828
        /// sub second register
        pub const SSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub second value
            SS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000282c
        /// shift control register
        pub const SHIFTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Subtract a fraction of a
            /// second
            SUBFS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Add one second
            ADD1S: u1,
        }), base_address + 0x2c);

        /// address: 0x40002830
        /// time stamp time register
        pub const TSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            reserved0: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            reserved1: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x30);

        /// address: 0x40002834
        /// time stamp date register
        pub const TSDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            reserved0: u1,
            reserved1: u1,
            /// Month units in BCD format
            MU: u4,
            /// Month tens in BCD format
            MT: u1,
            /// Week day units
            WDU: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40002838
        /// timestamp sub second register
        pub const TSSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub second value
            SS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x4000283c
        /// calibration register
        pub const CALR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Calibration minus
            CALM: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Use a 16-second calibration cycle
            /// period
            CALW16: u1,
            /// Use an 8-second calibration cycle
            /// period
            CALW8: u1,
            /// Increase frequency of RTC by 488.5
            /// ppm
            CALP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40002840
        /// tamper configuration register
        pub const TAMPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tamper 1 detection enable
            TAMP1E: u1,
            /// Active level for tamper 1
            TAMP1TRG: u1,
            /// Tamper interrupt enable
            TAMPIE: u1,
            /// Tamper 2 detection enable
            TAMP2E: u1,
            /// Active level for tamper 2
            TAMP2TRG: u1,
            /// Tamper 3 detection enable
            TAMP3E: u1,
            /// Active level for tamper 3
            TAMP3TRG: u1,
            /// Activate timestamp on tamper detection
            /// event
            TAMPTS: u1,
            /// Tamper sampling frequency
            TAMPFREQ: u3,
            /// Tamper filter count
            TAMPFLT: u2,
            /// Tamper precharge duration
            TAMPPRCH: u2,
            /// TAMPER pull-up disable
            TAMPPUDIS: u1,
            /// Tamper 1 interrupt enable
            TAMP1IE: u1,
            /// Tamper 1 no erase
            TAMP1NOERASE: u1,
            /// Tamper 1 mask flag
            TAMP1MF: u1,
            /// Tamper 2 interrupt enable
            TAMP2IE: u1,
            /// Tamper 2 no erase
            TAMP2NOERASE: u1,
            /// Tamper 2 mask flag
            TAMP2MF: u1,
            /// Tamper 3 interrupt enable
            TAMP3IE: u1,
            /// Tamper 3 no erase
            TAMP3NOERASE: u1,
            /// Tamper 3 mask flag
            TAMP3MF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x40);

        /// address: 0x40002844
        /// alarm A sub second register
        pub const ALRMASSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            SS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mask the most-significant bits starting
            /// at this bit
            MASKSS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x44);

        /// address: 0x40002848
        /// alarm B sub second register
        pub const ALRMBSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            SS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mask the most-significant bits starting
            /// at this bit
            MASKSS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x48);

        /// address: 0x4000284c
        /// option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC_ALARM on PC13 output
            /// type
            RTC_ALARM_TYPE: u1,
            /// RTC_OUT remap
            RTC_OUT_RMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4c);

        /// address: 0x40002850
        /// backup register
        pub const BKP0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x50);

        /// address: 0x40002854
        /// backup register
        pub const BKP1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x54);

        /// address: 0x40002858
        /// backup register
        pub const BKP2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x58);

        /// address: 0x4000285c
        /// backup register
        pub const BKP3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x5c);

        /// address: 0x40002860
        /// backup register
        pub const BKP4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x60);

        /// address: 0x40002864
        /// backup register
        pub const BKP5R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x64);

        /// address: 0x40002868
        /// backup register
        pub const BKP6R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x68);

        /// address: 0x4000286c
        /// backup register
        pub const BKP7R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x6c);

        /// address: 0x40002870
        /// backup register
        pub const BKP8R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x70);

        /// address: 0x40002874
        /// backup register
        pub const BKP9R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x74);

        /// address: 0x40002878
        /// backup register
        pub const BKP10R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x78);

        /// address: 0x4000287c
        /// backup register
        pub const BKP11R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x7c);

        /// address: 0x40002880
        /// backup register
        pub const BKP12R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x80);

        /// address: 0x40002884
        /// backup register
        pub const BKP13R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x84);

        /// address: 0x40002888
        /// backup register
        pub const BKP14R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x88);

        /// address: 0x4000288c
        /// backup register
        pub const BKP15R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x8c);

        /// address: 0x40002890
        /// backup register
        pub const BKP16R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x90);

        /// address: 0x40002894
        /// backup register
        pub const BKP17R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x94);

        /// address: 0x40002898
        /// backup register
        pub const BKP18R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x98);

        /// address: 0x4000289c
        /// backup register
        pub const BKP19R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x9c);

        /// address: 0x400028a0
        /// backup register
        pub const BKP20R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xa0);

        /// address: 0x400028a4
        /// backup register
        pub const BKP21R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xa4);

        /// address: 0x400028a8
        /// backup register
        pub const BKP22R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xa8);

        /// address: 0x400028ac
        /// backup register
        pub const BKP23R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xac);

        /// address: 0x400028b0
        /// backup register
        pub const BKP24R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xb0);

        /// address: 0x400028b4
        /// backup register
        pub const BKP25R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xb4);

        /// address: 0x400028b8
        /// backup register
        pub const BKP26R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xb8);

        /// address: 0x400028bc
        /// backup register
        pub const BKP27R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xbc);

        /// address: 0x400028c0
        /// backup register
        pub const BKP28R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xc0);

        /// address: 0x400028c4
        /// backup register
        pub const BKP29R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xc4);

        /// address: 0x400028c8
        /// backup register
        pub const BKP30R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xc8);

        /// address: 0x400028cc
        /// backup register
        pub const BKP31R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0xcc);
    };

    /// Single Wire Protocol Master
    /// Interface
    pub const SWPMI1 = struct {
        pub const base_address = 0x40008800;

        /// address: 0x40008800
        /// SWPMI Configuration/Control
        /// register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Reception DMA enable
            RXDMA: u1,
            /// Transmission DMA enable
            TXDMA: u1,
            /// Reception buffering mode
            RXMODE: u1,
            /// Transmission buffering
            /// mode
            TXMODE: u1,
            /// Loopback mode enable
            LPBK: u1,
            /// Single wire protocol master interface
            /// enable
            SWPME: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Single wire protocol master interface
            /// deactivate
            DEACT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x0);

        /// address: 0x40008804
        /// SWPMI Bitrate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bitrate prescaler
            BR: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x4);

        /// address: 0x4000880c
        /// SWPMI Interrupt and Status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer full flag
            RXBFF: u1,
            /// Transmit buffer empty flag
            TXBEF: u1,
            /// Receive CRC error flag
            RXBERF: u1,
            /// Receive overrun error flag
            RXOVRF: u1,
            /// Transmit underrun error
            /// flag
            TXUNRF: u1,
            /// Receive data register not
            /// empty
            RXNE: u1,
            /// Transmit data register
            /// empty
            TXE: u1,
            /// Transfer complete flag
            TCF: u1,
            /// Slave resume flag
            SRF: u1,
            /// SUSPEND flag
            SUSP: u1,
            /// DEACTIVATED flag
            DEACTF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0xc);

        /// address: 0x40008810
        /// SWPMI Interrupt Flag Clear
        /// register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear receive buffer full
            /// flag
            CRXBFF: u1,
            /// Clear transmit buffer empty
            /// flag
            CTXBEF: u1,
            /// Clear receive CRC error
            /// flag
            CRXBERF: u1,
            /// Clear receive overrun error
            /// flag
            CRXOVRF: u1,
            /// Clear transmit underrun error
            /// flag
            CTXUNRF: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clear transfer complete
            /// flag
            CTCF: u1,
            /// Clear slave resume flag
            CSRF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x10);

        /// address: 0x40008814
        /// SWPMI Interrupt Enable
        /// register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer full interrupt
            /// enable
            RXBFIE: u1,
            /// Transmit buffer empty interrupt
            /// enable
            TXBEIE: u1,
            /// Receive CRC error interrupt
            /// enable
            RXBERIE: u1,
            /// Receive overrun error interrupt
            /// enable
            RXOVRIE: u1,
            /// Transmit underrun error interrupt
            /// enable
            TXUNRIE: u1,
            /// Receive interrupt enable
            RIE: u1,
            /// Transmit interrupt enable
            TIE: u1,
            /// Transmit complete interrupt
            /// enable
            TCIE: u1,
            /// Slave resume interrupt
            /// enable
            SRIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x14);

        /// address: 0x40008818
        /// SWPMI Receive Frame Length
        /// register
        pub const RFL = @intToPtr(*volatile MmioInt(32, u5), base_address + 0x18);

        /// address: 0x4000881c
        /// SWPMI Transmit data register
        pub const TDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data
            TD: u32,
        }), base_address + 0x1c);

        /// address: 0x40008820
        /// SWPMI Receive data register
        pub const RDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// received data
            RD: u32,
        }), base_address + 0x20);
    };

    /// Operational amplifiers
    pub const OPAMP = struct {
        pub const base_address = 0x40007800;

        /// address: 0x40007800
        /// OPAMP1 control/status register
        pub const OPAMP1_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Operational amplifier
            /// Enable
            OPAEN: u1,
            /// Operational amplifier Low Power
            /// Mode
            OPALPM: u1,
            /// Operational amplifier PGA
            /// mode
            OPAMODE: u2,
            /// Operational amplifier Programmable
            /// amplifier gain value
            PGA_GAIN: u2,
            reserved0: u1,
            reserved1: u1,
            /// Inverting input selection
            VM_SEL: u2,
            /// Non inverted input
            /// selection
            VP_SEL: u1,
            reserved2: u1,
            /// Calibration mode enabled
            CALON: u1,
            /// Calibration selection
            CALSEL: u1,
            /// allows to switch from AOP offset trimmed
            /// values to AOP offset
            USERTRIM: u1,
            /// Operational amplifier calibration
            /// output
            CALOUT: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// Operational amplifier power supply range
            /// for stability
            OPA_RANGE: u1,
        }), base_address + 0x0);

        /// address: 0x40007804
        /// OPAMP1 offset trimming register in normal
        /// mode
        pub const OPAMP1_OTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Trim for NMOS differential
            /// pairs
            TRIMOFFSETN: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trim for PMOS differential
            /// pairs
            TRIMOFFSETP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x4);

        /// address: 0x40007808
        /// OPAMP1 offset trimming register in low-power
        /// mode
        pub const OPAMP1_LPOTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Trim for NMOS differential
            /// pairs
            TRIMLPOFFSETN: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trim for PMOS differential
            /// pairs
            TRIMLPOFFSETP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x8);

        /// address: 0x40007810
        /// OPAMP2 control/status register
        pub const OPAMP2_CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Operational amplifier
            /// Enable
            OPAEN: u1,
            /// Operational amplifier Low Power
            /// Mode
            OPALPM: u1,
            /// Operational amplifier PGA
            /// mode
            OPAMODE: u2,
            /// Operational amplifier Programmable
            /// amplifier gain value
            PGA_GAIN: u2,
            reserved0: u1,
            reserved1: u1,
            /// Inverting input selection
            VM_SEL: u2,
            /// Non inverted input
            /// selection
            VP_SEL: u1,
            reserved2: u1,
            /// Calibration mode enabled
            CALON: u1,
            /// Calibration selection
            CALSEL: u1,
            /// allows to switch from AOP offset trimmed
            /// values to AOP offset
            USERTRIM: u1,
            /// Operational amplifier calibration
            /// output
            CALOUT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40007814
        /// OPAMP2 offset trimming register in normal
        /// mode
        pub const OPAMP2_OTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Trim for NMOS differential
            /// pairs
            TRIMOFFSETN: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trim for PMOS differential
            /// pairs
            TRIMOFFSETP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x14);

        /// address: 0x40007818
        /// OPAMP2 offset trimming register in low-power
        /// mode
        pub const OPAMP2_LPOTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Trim for NMOS differential
            /// pairs
            TRIMLPOFFSETN: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trim for PMOS differential
            /// pairs
            TRIMLPOFFSETP: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x18);
    };

    /// Nested Vectored Interrupt
    /// Controller
    pub const NVIC = struct {
        pub const base_address = 0xe000e100;

        /// address: 0xe000e100
        /// Interrupt Set-Enable Register
        pub const ISER0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETENA
            SETENA: u32,
        }), base_address + 0x0);

        /// address: 0xe000e104
        /// Interrupt Set-Enable Register
        pub const ISER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETENA
            SETENA: u32,
        }), base_address + 0x4);

        /// address: 0xe000e108
        /// Interrupt Set-Enable Register
        pub const ISER2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETENA
            SETENA: u32,
        }), base_address + 0x8);

        /// address: 0xe000e180
        /// Interrupt Clear-Enable
        /// Register
        pub const ICER0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRENA
            CLRENA: u32,
        }), base_address + 0x80);

        /// address: 0xe000e184
        /// Interrupt Clear-Enable
        /// Register
        pub const ICER1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRENA
            CLRENA: u32,
        }), base_address + 0x84);

        /// address: 0xe000e188
        /// Interrupt Clear-Enable
        /// Register
        pub const ICER2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRENA
            CLRENA: u32,
        }), base_address + 0x88);

        /// address: 0xe000e200
        /// Interrupt Set-Pending Register
        pub const ISPR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETPEND
            SETPEND: u32,
        }), base_address + 0x100);

        /// address: 0xe000e204
        /// Interrupt Set-Pending Register
        pub const ISPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETPEND
            SETPEND: u32,
        }), base_address + 0x104);

        /// address: 0xe000e208
        /// Interrupt Set-Pending Register
        pub const ISPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETPEND
            SETPEND: u32,
        }), base_address + 0x108);

        /// address: 0xe000e280
        /// Interrupt Clear-Pending
        /// Register
        pub const ICPR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRPEND
            CLRPEND: u32,
        }), base_address + 0x180);

        /// address: 0xe000e284
        /// Interrupt Clear-Pending
        /// Register
        pub const ICPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRPEND
            CLRPEND: u32,
        }), base_address + 0x184);

        /// address: 0xe000e288
        /// Interrupt Clear-Pending
        /// Register
        pub const ICPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRPEND
            CLRPEND: u32,
        }), base_address + 0x188);

        /// address: 0xe000e300
        /// Interrupt Active Bit Register
        pub const IABR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ACTIVE
            ACTIVE: u32,
        }), base_address + 0x200);

        /// address: 0xe000e304
        /// Interrupt Active Bit Register
        pub const IABR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ACTIVE
            ACTIVE: u32,
        }), base_address + 0x204);

        /// address: 0xe000e308
        /// Interrupt Active Bit Register
        pub const IABR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// ACTIVE
            ACTIVE: u32,
        }), base_address + 0x208);

        /// address: 0xe000e400
        /// Interrupt Priority Register
        pub const IPR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x300);

        /// address: 0xe000e404
        /// Interrupt Priority Register
        pub const IPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x304);

        /// address: 0xe000e408
        /// Interrupt Priority Register
        pub const IPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x308);

        /// address: 0xe000e40c
        /// Interrupt Priority Register
        pub const IPR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x30c);

        /// address: 0xe000e410
        /// Interrupt Priority Register
        pub const IPR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x310);

        /// address: 0xe000e414
        /// Interrupt Priority Register
        pub const IPR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x314);

        /// address: 0xe000e418
        /// Interrupt Priority Register
        pub const IPR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x318);

        /// address: 0xe000e41c
        /// Interrupt Priority Register
        pub const IPR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x31c);

        /// address: 0xe000e420
        /// Interrupt Priority Register
        pub const IPR8 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x320);

        /// address: 0xe000e424
        /// Interrupt Priority Register
        pub const IPR9 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x324);

        /// address: 0xe000e428
        /// Interrupt Priority Register
        pub const IPR10 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x328);

        /// address: 0xe000e42c
        /// Interrupt Priority Register
        pub const IPR11 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x32c);

        /// address: 0xe000e430
        /// Interrupt Priority Register
        pub const IPR12 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x330);

        /// address: 0xe000e434
        /// Interrupt Priority Register
        pub const IPR13 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x334);

        /// address: 0xe000e438
        /// Interrupt Priority Register
        pub const IPR14 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x338);

        /// address: 0xe000e43c
        /// Interrupt Priority Register
        pub const IPR15 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x33c);

        /// address: 0xe000e440
        /// Interrupt Priority Register
        pub const IPR16 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x340);

        /// address: 0xe000e444
        /// Interrupt Priority Register
        pub const IPR17 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x344);

        /// address: 0xe000e448
        /// Interrupt Priority Register
        pub const IPR18 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x348);

        /// address: 0xe000e44c
        /// Interrupt Priority Register
        pub const IPR19 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x34c);

        /// address: 0xe000e450
        /// Interrupt Priority Register
        pub const IPR20 = @intToPtr(*volatile Mmio(32, packed struct {
            /// IPR_N0
            IPR_N0: u8,
            /// IPR_N1
            IPR_N1: u8,
            /// IPR_N2
            IPR_N2: u8,
            /// IPR_N3
            IPR_N3: u8,
        }), base_address + 0x350);
    };

    /// Clock recovery system
    pub const CRS = struct {
        pub const base_address = 0x40006000;

        /// address: 0x40006000
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SYNC event OK interrupt
            /// enable
            SYNCOKIE: u1,
            /// SYNC warning interrupt
            /// enable
            SYNCWARNIE: u1,
            /// Synchronization or trimming error
            /// interrupt enable
            ERRIE: u1,
            /// Expected SYNC interrupt
            /// enable
            ESYNCIE: u1,
            reserved0: u1,
            /// Frequency error counter
            /// enable
            CEN: u1,
            /// Automatic trimming enable
            AUTOTRIMEN: u1,
            /// Generate software SYNC
            /// event
            SWSYNC: u1,
            /// HSI48 oscillator smooth
            /// trimming
            TRIM: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x0);

        /// address: 0x40006004
        /// configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter reload value
            RELOAD: u16,
            /// Frequency error limit
            FELIM: u8,
            /// SYNC divider
            SYNCDIV: u3,
            reserved0: u1,
            /// SYNC signal source
            /// selection
            SYNCSRC: u2,
            reserved1: u1,
            /// SYNC polarity selection
            SYNCPOL: u1,
        }), base_address + 0x4);

        /// address: 0x40006008
        /// interrupt and status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SYNC event OK flag
            SYNCOKF: u1,
            /// SYNC warning flag
            SYNCWARNF: u1,
            /// Error flag
            ERRF: u1,
            /// Expected SYNC flag
            ESYNCF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// SYNC error
            SYNCERR: u1,
            /// SYNC missed
            SYNCMISS: u1,
            /// Trimming overflow or
            /// underflow
            TRIMOVF: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Frequency error direction
            FEDIR: u1,
            /// Frequency error capture
            FECAP: u16,
        }), base_address + 0x8);

        /// address: 0x4000600c
        /// interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SYNC event OK clear flag
            SYNCOKC: u1,
            /// SYNC warning clear flag
            SYNCWARNC: u1,
            /// Error clear flag
            ERRC: u1,
            /// Expected SYNC clear flag
            ESYNCC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0xc);
    };

    /// Universal serial bus full-speed device
    /// interface
    pub const USB_SRAM = struct {
        pub const base_address = 0x40006c00;

        /// address: 0x40006c00
        /// endpoint 0 register
        pub const EP0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40006c04
        /// endpoint 1 register
        pub const EP1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40006c08
        /// endpoint 2 register
        pub const EP2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x40006c0c
        /// endpoint 3 register
        pub const EP3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40006c10
        /// endpoint 4 register
        pub const EP4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40006c14
        /// endpoint 5 register
        pub const EP5R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40006c18
        /// endpoint 6 register
        pub const EP6R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40006c1c
        /// endpoint 7 register
        pub const EP7R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40006c40
        /// control register
        pub const CNTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Force USB Reset
            FRES: u1,
            /// Power down
            PDWN: u1,
            /// Low-power mode
            LPMODE: u1,
            /// Force suspend
            FSUSP: u1,
            /// Resume request
            RESUME: u1,
            /// LPM L1 Resume request
            L1RESUME: u1,
            reserved0: u1,
            /// LPM L1 state request interrupt
            /// mask
            L1REQM: u1,
            /// Expected start of frame interrupt
            /// mask
            ESOFM: u1,
            /// Start of frame interrupt
            /// mask
            SOFM: u1,
            /// USB reset interrupt mask
            RESETM: u1,
            /// Suspend mode interrupt
            /// mask
            SUSPM: u1,
            /// Wakeup interrupt mask
            WKUPM: u1,
            /// Error interrupt mask
            ERRM: u1,
            /// Packet memory area over / underrun
            /// interrupt mask
            PMAOVRM: u1,
            /// Correct transfer interrupt
            /// mask
            CTRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40006c44
        /// interrupt status register
        pub const ISTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint Identifier
            EP_ID: u4,
            /// Direction of transaction
            DIR: u1,
            reserved0: u1,
            reserved1: u1,
            /// LPM L1 state request
            L1REQ: u1,
            /// Expected start frame
            ESOF: u1,
            /// start of frame
            SOF: u1,
            /// reset request
            RESET: u1,
            /// Suspend mode request
            SUSP: u1,
            /// Wakeup
            WKUP: u1,
            /// Error
            ERR: u1,
            /// Packet memory area over /
            /// underrun
            PMAOVR: u1,
            /// Correct transfer
            CTR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40006c48
        /// frame number register
        pub const FNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame number
            FN: u11,
            /// Lost SOF
            LSOF: u2,
            /// Locked
            LCK: u1,
            /// Receive data - line status
            RXDM: u1,
            /// Receive data + line status
            RXDP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x40006c4c
        /// device address
        pub const DADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADD: u7,
            /// Enable function
            EF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4c);

        /// address: 0x40006c50
        /// Buffer table address
        pub const BTABLE = @intToPtr(*volatile MmioInt(32, u13), base_address + 0x50);

        /// address: 0x40006c54
        /// LPM control and status
        /// register
        pub const LPMCSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LPM support enable
            LPMEN: u1,
            /// LPM Token acknowledge
            /// enable
            LPMACK: u1,
            reserved0: u1,
            /// bRemoteWake value
            REMWAKE: u1,
            /// BESL value
            BESL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x54);

        /// address: 0x40006c58
        /// Battery charging detector
        pub const BCDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Battery charging detector
            BCDEN: u1,
            /// Data contact detection
            DCDEN: u1,
            /// Primary detection
            PDEN: u1,
            /// Secondary detection
            SDEN: u1,
            /// Data contact detection
            DCDET: u1,
            /// Primary detection
            PDET: u1,
            /// Secondary detection
            SDET: u1,
            /// DM pull-up detection
            /// status
            PS2DET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// DP pull-up control
            DPPU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x58);
    };
    pub const USB_FS = struct {
        pub const base_address = 0x40006800;

        /// address: 0x40006800
        /// endpoint 0 register
        pub const EP0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40006804
        /// endpoint 1 register
        pub const EP1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x40006808
        /// endpoint 2 register
        pub const EP2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000680c
        /// endpoint 3 register
        pub const EP3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40006810
        /// endpoint 4 register
        pub const EP4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40006814
        /// endpoint 5 register
        pub const EP5R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40006818
        /// endpoint 6 register
        pub const EP6R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000681c
        /// endpoint 7 register
        pub const EP7R = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint address
            EA: u4,
            /// Status bits, for transmission
            /// transfers
            STAT_TX: u2,
            /// Data Toggle, for transmission
            /// transfers
            DTOG_TX: u1,
            /// Correct Transfer for
            /// transmission
            CTR_TX: u1,
            /// Endpoint kind
            EP_KIND: u1,
            /// Endpoint type
            EP_TYPE: u2,
            /// Setup transaction
            /// completed
            SETUP: u1,
            /// Status bits, for reception
            /// transfers
            STAT_RX: u2,
            /// Data Toggle, for reception
            /// transfers
            DTOG_RX: u1,
            /// Correct transfer for
            /// reception
            CTR_RX: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40006840
        /// control register
        pub const CNTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Force USB Reset
            FRES: u1,
            /// Power down
            PDWN: u1,
            /// Low-power mode
            LPMODE: u1,
            /// Force suspend
            FSUSP: u1,
            /// Resume request
            RESUME: u1,
            /// LPM L1 Resume request
            L1RESUME: u1,
            reserved0: u1,
            /// LPM L1 state request interrupt
            /// mask
            L1REQM: u1,
            /// Expected start of frame interrupt
            /// mask
            ESOFM: u1,
            /// Start of frame interrupt
            /// mask
            SOFM: u1,
            /// USB reset interrupt mask
            RESETM: u1,
            /// Suspend mode interrupt
            /// mask
            SUSPM: u1,
            /// Wakeup interrupt mask
            WKUPM: u1,
            /// Error interrupt mask
            ERRM: u1,
            /// Packet memory area over / underrun
            /// interrupt mask
            PMAOVRM: u1,
            /// Correct transfer interrupt
            /// mask
            CTRM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40006844
        /// interrupt status register
        pub const ISTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Endpoint Identifier
            EP_ID: u4,
            /// Direction of transaction
            DIR: u1,
            reserved0: u1,
            reserved1: u1,
            /// LPM L1 state request
            L1REQ: u1,
            /// Expected start frame
            ESOF: u1,
            /// start of frame
            SOF: u1,
            /// reset request
            RESET: u1,
            /// Suspend mode request
            SUSP: u1,
            /// Wakeup
            WKUP: u1,
            /// Error
            ERR: u1,
            /// Packet memory area over /
            /// underrun
            PMAOVR: u1,
            /// Correct transfer
            CTR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x44);

        /// address: 0x40006848
        /// frame number register
        pub const FNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Frame number
            FN: u11,
            /// Lost SOF
            LSOF: u2,
            /// Locked
            LCK: u1,
            /// Receive data - line status
            RXDM: u1,
            /// Receive data + line status
            RXDP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4000684c
        /// device address
        pub const DADDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device address
            ADD: u7,
            /// Enable function
            EF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4c);

        /// address: 0x40006850
        /// Buffer table address
        pub const BTABLE = @intToPtr(*volatile MmioInt(32, u13), base_address + 0x50);

        /// address: 0x40006854
        /// LPM control and status
        /// register
        pub const LPMCSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LPM support enable
            LPMEN: u1,
            /// LPM Token acknowledge
            /// enable
            LPMACK: u1,
            reserved0: u1,
            /// bRemoteWake value
            REMWAKE: u1,
            /// BESL value
            BESL: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x54);

        /// address: 0x40006858
        /// Battery charging detector
        pub const BCDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Battery charging detector
            BCDEN: u1,
            /// Data contact detection
            DCDEN: u1,
            /// Primary detection
            PDEN: u1,
            /// Secondary detection
            SDEN: u1,
            /// Data contact detection
            DCDET: u1,
            /// Primary detection
            PDET: u1,
            /// Secondary detection
            SDET: u1,
            /// DM pull-up detection
            /// status
            PS2DET: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// DP pull-up control
            DPPU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x58);
    };

    /// Digital filter for sigma delta
    /// modulators
    pub const DFSDM = struct {
        pub const base_address = 0x40016000;

        /// address: 0x40016000
        /// channel configuration y
        /// register
        pub const CH0CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SITP
            SITP: u2,
            /// SPICKSEL
            SPICKSEL: u2,
            reserved0: u1,
            /// SCDEN
            SCDEN: u1,
            /// CKABEN
            CKABEN: u1,
            /// CHEN
            CHEN: u1,
            /// CHINSEL
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DATMPX
            DATMPX: u2,
            /// DATPACK
            DATPACK: u2,
            /// CKOUTDIV
            CKOUTDIV: u8,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// CKOUTSRC
            CKOUTSRC: u1,
            /// DFSDMEN
            DFSDMEN: u1,
        }), base_address + 0x0);

        /// address: 0x40016004
        /// channel configuration y
        /// register
        pub const CH0CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DTRBS
            DTRBS: u5,
            /// OFFSET
            OFFSET: u24,
        }), base_address + 0x4);

        /// address: 0x40016008
        /// analog watchdog and short-circuit detector
        /// register
        pub const CH0AWSCDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCDT
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BKSCD
            BKSCD: u4,
            /// AWFOSR
            AWFOSR: u5,
            reserved4: u1,
            /// AWFORD
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x4001600c
        /// channel watchdog filter data
        /// register
        pub const CH0WDATR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WDATA
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40016010
        /// channel data input register
        pub const CH0DATINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INDAT0
            INDAT0: u16,
            /// INDAT1
            INDAT1: u16,
        }), base_address + 0x10);

        /// address: 0x40016014
        /// channel y delay register
        pub const CH0DLYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLSSKP
            PLSSKP: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x14);

        /// address: 0x40016020
        /// CH1CFGR1
        pub const CH1CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SITP
            SITP: u2,
            /// SPICKSEL
            SPICKSEL: u2,
            reserved0: u1,
            /// SCDEN
            SCDEN: u1,
            /// CKABEN
            CKABEN: u1,
            /// CHEN
            CHEN: u1,
            /// CHINSEL
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DATMPX
            DATMPX: u2,
            /// DATPACK
            DATPACK: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40016024
        /// CH1CFGR2
        pub const CH1CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DTRBS
            DTRBS: u5,
            /// OFFSET
            OFFSET: u24,
        }), base_address + 0x24);

        /// address: 0x40016028
        /// CH1AWSCDR
        pub const CH1AWSCDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCDT
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BKSCD
            BKSCD: u4,
            /// AWFOSR
            AWFOSR: u5,
            reserved4: u1,
            /// AWFORD
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x28);

        /// address: 0x4001602c
        /// CH1WDATR
        pub const CH1WDATR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WDATA
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0x40016030
        /// CH1DATINR
        pub const CH1DATINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INDAT0
            INDAT0: u16,
            /// INDAT1
            INDAT1: u16,
        }), base_address + 0x30);

        /// address: 0x40016034
        /// channel y delay register
        pub const CH1DLYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLSSKP
            PLSSKP: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x34);

        /// address: 0x40016040
        /// CH2CFGR1
        pub const CH2CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SITP
            SITP: u2,
            /// SPICKSEL
            SPICKSEL: u2,
            reserved0: u1,
            /// SCDEN
            SCDEN: u1,
            /// CKABEN
            CKABEN: u1,
            /// CHEN
            CHEN: u1,
            /// CHINSEL
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DATMPX
            DATMPX: u2,
            /// DATPACK
            DATPACK: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x40016044
        /// CH2CFGR2
        pub const CH2CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DTRBS
            DTRBS: u5,
            /// OFFSET
            OFFSET: u24,
        }), base_address + 0x44);

        /// address: 0x40016048
        /// CH2AWSCDR
        pub const CH2AWSCDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCDT
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BKSCD
            BKSCD: u4,
            /// AWFOSR
            AWFOSR: u5,
            reserved4: u1,
            /// AWFORD
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x48);

        /// address: 0x4001604c
        /// CH2WDATR
        pub const CH2WDATR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WDATA
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40016050
        /// CH2DATINR
        pub const CH2DATINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INDAT0
            INDAT0: u16,
            /// INDAT1
            INDAT1: u16,
        }), base_address + 0x50);

        /// address: 0x40016054
        /// channel y delay register
        pub const CH2DLYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLSSKP
            PLSSKP: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x54);

        /// address: 0x40016060
        /// CH3CFGR1
        pub const CH3CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SITP
            SITP: u2,
            /// SPICKSEL
            SPICKSEL: u2,
            reserved0: u1,
            /// SCDEN
            SCDEN: u1,
            /// CKABEN
            CKABEN: u1,
            /// CHEN
            CHEN: u1,
            /// CHINSEL
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DATMPX
            DATMPX: u2,
            /// DATPACK
            DATPACK: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x60);

        /// address: 0x40016064
        /// CH3CFGR2
        pub const CH3CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DTRBS
            DTRBS: u5,
            /// OFFSET
            OFFSET: u24,
        }), base_address + 0x64);

        /// address: 0x40016068
        /// CH3AWSCDR
        pub const CH3AWSCDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCDT
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BKSCD
            BKSCD: u4,
            /// AWFOSR
            AWFOSR: u5,
            reserved4: u1,
            /// AWFORD
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x68);

        /// address: 0x4001606c
        /// CH3WDATR
        pub const CH3WDATR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WDATA
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x6c);

        /// address: 0x40016070
        /// CH3DATINR
        pub const CH3DATINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INDAT0
            INDAT0: u16,
            /// INDAT1
            INDAT1: u16,
        }), base_address + 0x70);

        /// address: 0x40016074
        /// channel y delay register
        pub const CH3DLYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLSSKP
            PLSSKP: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x74);

        /// address: 0x40016080
        /// CH4CFGR1
        pub const CH4CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SITP
            SITP: u2,
            /// SPICKSEL
            SPICKSEL: u2,
            reserved0: u1,
            /// SCDEN
            SCDEN: u1,
            /// CKABEN
            CKABEN: u1,
            /// CHEN
            CHEN: u1,
            /// CHINSEL
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DATMPX
            DATMPX: u2,
            /// DATPACK
            DATPACK: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x80);

        /// address: 0x40016084
        /// CH4CFGR2
        pub const CH4CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DTRBS
            DTRBS: u5,
            /// OFFSET
            OFFSET: u24,
        }), base_address + 0x84);

        /// address: 0x40016088
        /// CH4AWSCDR
        pub const CH4AWSCDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCDT
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BKSCD
            BKSCD: u4,
            /// AWFOSR
            AWFOSR: u5,
            reserved4: u1,
            /// AWFORD
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x88);

        /// address: 0x4001608c
        /// CH4WDATR
        pub const CH4WDATR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WDATA
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8c);

        /// address: 0x40016090
        /// CH4DATINR
        pub const CH4DATINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INDAT0
            INDAT0: u16,
            /// INDAT1
            INDAT1: u16,
        }), base_address + 0x90);

        /// address: 0x40016094
        /// channel y delay register
        pub const CH4DLYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLSSKP
            PLSSKP: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x94);

        /// address: 0x400160a0
        /// CH5CFGR1
        pub const CH5CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SITP
            SITP: u2,
            /// SPICKSEL
            SPICKSEL: u2,
            reserved0: u1,
            /// SCDEN
            SCDEN: u1,
            /// CKABEN
            CKABEN: u1,
            /// CHEN
            CHEN: u1,
            /// CHINSEL
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DATMPX
            DATMPX: u2,
            /// DATPACK
            DATPACK: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xa0);

        /// address: 0x400160a4
        /// CH5CFGR2
        pub const CH5CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DTRBS
            DTRBS: u5,
            /// OFFSET
            OFFSET: u24,
        }), base_address + 0xa4);

        /// address: 0x400160a8
        /// CH5AWSCDR
        pub const CH5AWSCDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCDT
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BKSCD
            BKSCD: u4,
            /// AWFOSR
            AWFOSR: u5,
            reserved4: u1,
            /// AWFORD
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xa8);

        /// address: 0x400160ac
        /// CH5WDATR
        pub const CH5WDATR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WDATA
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xac);

        /// address: 0x400160b0
        /// CH5DATINR
        pub const CH5DATINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INDAT0
            INDAT0: u16,
            /// INDAT1
            INDAT1: u16,
        }), base_address + 0xb0);

        /// address: 0x400160b4
        /// channel y delay register
        pub const CH5DLYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLSSKP
            PLSSKP: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xb4);

        /// address: 0x400160c0
        /// CH6CFGR1
        pub const CH6CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SITP
            SITP: u2,
            /// SPICKSEL
            SPICKSEL: u2,
            reserved0: u1,
            /// SCDEN
            SCDEN: u1,
            /// CKABEN
            CKABEN: u1,
            /// CHEN
            CHEN: u1,
            /// CHINSEL
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DATMPX
            DATMPX: u2,
            /// DATPACK
            DATPACK: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc0);

        /// address: 0x400160c4
        /// CH6CFGR2
        pub const CH6CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DTRBS
            DTRBS: u5,
            /// OFFSET
            OFFSET: u24,
        }), base_address + 0xc4);

        /// address: 0x400160c8
        /// CH6AWSCDR
        pub const CH6AWSCDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCDT
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BKSCD
            BKSCD: u4,
            /// AWFOSR
            AWFOSR: u5,
            reserved4: u1,
            /// AWFORD
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xc8);

        /// address: 0x400160cc
        /// CH6WDATR
        pub const CH6WDATR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WDATA
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xcc);

        /// address: 0x400160d0
        /// CH6DATINR
        pub const CH6DATINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INDAT0
            INDAT0: u16,
            /// INDAT1
            INDAT1: u16,
        }), base_address + 0xd0);

        /// address: 0x400160d4
        /// channel y delay register
        pub const CH6DLYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLSSKP
            PLSSKP: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xd4);

        /// address: 0x400160e0
        /// CH7CFGR1
        pub const CH7CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// SITP
            SITP: u2,
            /// SPICKSEL
            SPICKSEL: u2,
            reserved0: u1,
            /// SCDEN
            SCDEN: u1,
            /// CKABEN
            CKABEN: u1,
            /// CHEN
            CHEN: u1,
            /// CHINSEL
            CHINSEL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// DATMPX
            DATMPX: u2,
            /// DATPACK
            DATPACK: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xe0);

        /// address: 0x400160e4
        /// CH7CFGR2
        pub const CH7CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DTRBS
            DTRBS: u5,
            /// OFFSET
            OFFSET: u24,
        }), base_address + 0xe4);

        /// address: 0x400160e8
        /// CH7AWSCDR
        pub const CH7AWSCDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCDT
            SCDT: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BKSCD
            BKSCD: u4,
            /// AWFOSR
            AWFOSR: u5,
            reserved4: u1,
            /// AWFORD
            AWFORD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0xe8);

        /// address: 0x400160ec
        /// CH7WDATR
        pub const CH7WDATR = @intToPtr(*volatile Mmio(32, packed struct {
            /// WDATA
            WDATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xec);

        /// address: 0x400160f0
        /// CH7DATINR
        pub const CH7DATINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// INDAT0
            INDAT0: u16,
            /// INDAT1
            INDAT1: u16,
        }), base_address + 0xf0);

        /// address: 0x400160f4
        /// channel y delay register
        pub const CH7DLYR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PLSSKP
            PLSSKP: u6,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xf4);

        /// address: 0x40016100
        /// control register 1
        pub const DFSDM_FLT0CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DFSDM enable
            DFEN: u1,
            /// Start a conversion of the injected group
            /// of channels
            JSWSTART: u1,
            reserved0: u1,
            /// Launch an injected conversion
            /// synchronously with the DFSDM0 JSWSTART
            /// trigger
            JSYNC: u1,
            /// Scanning conversion mode for injected
            /// conversions
            JSCAN: u1,
            /// DMA channel enabled to read data for the
            /// injected channel group
            JDMAEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger signal selection for launching
            /// injected conversions
            JEXTSEL: u3,
            reserved3: u1,
            reserved4: u1,
            /// Trigger enable and trigger edge
            /// selection for injected conversions
            JEXTEN: u2,
            reserved5: u1,
            reserved6: u1,
            /// Software start of a conversion on the
            /// regular channel
            RSWSTART: u1,
            /// Continuous mode selection for regular
            /// conversions
            RCONT: u1,
            /// Launch regular conversion synchronously
            /// with DFSDM0
            RSYNC: u1,
            reserved7: u1,
            /// DMA channel enabled to read data for the
            /// regular conversion
            RDMAEN: u1,
            reserved8: u1,
            reserved9: u1,
            /// Regular channel selection
            RCH: u3,
            reserved10: u1,
            reserved11: u1,
            /// Fast conversion mode selection for
            /// regular conversions
            FAST: u1,
            /// Analog watchdog fast mode
            /// select
            AWFSEL: u1,
            padding0: u1,
        }), base_address + 0x100);

        /// address: 0x40016104
        /// control register 2
        pub const DFSDM_FLT0CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected end of conversion interrupt
            /// enable
            JEOCIE: u1,
            /// Regular end of conversion interrupt
            /// enable
            REOCIE: u1,
            /// Injected data overrun interrupt
            /// enable
            JOVRIE: u1,
            /// Regular data overrun interrupt
            /// enable
            ROVRIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Short-circuit detector interrupt
            /// enable
            SCDIE: u1,
            /// Clock absence interrupt
            /// enable
            CKABIE: u1,
            reserved0: u1,
            /// Extremes detector channel
            /// selection
            EXCH: u8,
            /// Analog watchdog channel
            /// selection
            AWDCH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x104);

        /// address: 0x40016108
        /// interrupt and status register
        pub const DFSDM_FLT0ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of injected conversion
            /// flag
            JEOCF: u1,
            /// End of regular conversion
            /// flag
            REOCF: u1,
            /// Injected conversion overrun
            /// flag
            JOVRF: u1,
            /// Regular conversion overrun
            /// flag
            ROVRF: u1,
            /// Analog watchdog
            AWDF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Injected conversion in progress
            /// status
            JCIP: u1,
            /// Regular conversion in progress
            /// status
            RCIP: u1,
            reserved8: u1,
            /// Clock absence flag
            CKABF: u8,
            /// short-circuit detector
            /// flag
            SCDF: u8,
        }), base_address + 0x108);

        /// address: 0x4001610c
        /// interrupt flag clear register
        pub const DFSDM_FLT0ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Clear the injected conversion overrun
            /// flag
            CLRJOVRF: u1,
            /// Clear the regular conversion overrun
            /// flag
            CLRROVRF: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the clock absence
            /// flag
            CLRCKABF: u8,
            /// Clear the short-circuit detector
            /// flag
            CLRSCDF: u8,
        }), base_address + 0x10c);

        /// address: 0x40016110
        /// injected channel group selection
        /// register
        pub const DFSDM_FLT0JCHGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel group
            /// selection
            JCHG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x110);

        /// address: 0x40016114
        /// filter control register
        pub const DFSDM_FLT0FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integrator oversampling ratio (averaging
            /// length)
            IOSR: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Sinc filter oversampling ratio
            /// (decimation rate)
            FOSR: u10,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Sinc filter order
            FORD: u3,
        }), base_address + 0x114);

        /// address: 0x40016118
        /// data register for injected
        /// group
        pub const DFSDM_FLT0JDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel most recently
            /// converted
            JDATACH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Injected group conversion
            /// data
            JDATA: u24,
        }), base_address + 0x118);

        /// address: 0x4001611c
        /// data register for the regular
        /// channel
        pub const DFSDM_FLT0RDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular channel most recently
            /// converted
            RDATACH: u3,
            reserved0: u1,
            /// Regular channel pending
            /// data
            RPEND: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Regular channel conversion
            /// data
            RDATA: u24,
        }), base_address + 0x11c);

        /// address: 0x40016120
        /// analog watchdog high threshold
        /// register
        pub const DFSDM_FLT0AWHTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog high threshold event
            BKAWH: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog high
            /// threshold
            AWHT: u24,
        }), base_address + 0x120);

        /// address: 0x40016124
        /// analog watchdog low threshold
        /// register
        pub const DFSDM_FLT0AWLTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog low threshold event
            BKAWL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog low
            /// threshold
            AWLT: u24,
        }), base_address + 0x124);

        /// address: 0x40016128
        /// analog watchdog status
        /// register
        pub const DFSDM_FLT0AWSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog low threshold
            /// flag
            AWLTF: u8,
            /// Analog watchdog high threshold
            /// flag
            AWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x128);

        /// address: 0x4001612c
        /// analog watchdog clear flag
        /// register
        pub const DFSDM_FLT0AWCFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the analog watchdog low threshold
            /// flag
            CLRAWLTF: u8,
            /// Clear the analog watchdog high threshold
            /// flag
            CLRAWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x12c);

        /// address: 0x40016130
        /// Extremes detector maximum
        /// register
        pub const DFSDM_FLT0EXMAX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector maximum data
            /// channel
            EXMAXCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector maximum
            /// value
            EXMAX: u24,
        }), base_address + 0x130);

        /// address: 0x40016134
        /// Extremes detector minimum
        /// register
        pub const DFSDM_FLT0EXMIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector minimum data
            /// channel
            EXMINCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// EXMIN
            EXMIN: u24,
        }), base_address + 0x134);

        /// address: 0x40016138
        /// conversion timer register
        pub const DFSDM_FLT0CNVTIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 28-bit timer counting conversion time t
            /// = CNVCNT[27:0] / fDFSDM_CKIN
            CNVCNT: u28,
        }), base_address + 0x138);

        /// address: 0x40016180
        /// control register 1
        pub const DFSDM_FLT1CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DFSDM enable
            DFEN: u1,
            /// Start a conversion of the injected group
            /// of channels
            JSWSTART: u1,
            reserved0: u1,
            /// Launch an injected conversion
            /// synchronously with the DFSDM0 JSWSTART
            /// trigger
            JSYNC: u1,
            /// Scanning conversion mode for injected
            /// conversions
            JSCAN: u1,
            /// DMA channel enabled to read data for the
            /// injected channel group
            JDMAEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger signal selection for launching
            /// injected conversions
            JEXTSEL: u3,
            reserved3: u1,
            reserved4: u1,
            /// Trigger enable and trigger edge
            /// selection for injected conversions
            JEXTEN: u2,
            reserved5: u1,
            reserved6: u1,
            /// Software start of a conversion on the
            /// regular channel
            RSWSTART: u1,
            /// Continuous mode selection for regular
            /// conversions
            RCONT: u1,
            /// Launch regular conversion synchronously
            /// with DFSDM0
            RSYNC: u1,
            reserved7: u1,
            /// DMA channel enabled to read data for the
            /// regular conversion
            RDMAEN: u1,
            reserved8: u1,
            reserved9: u1,
            /// Regular channel selection
            RCH: u3,
            reserved10: u1,
            reserved11: u1,
            /// Fast conversion mode selection for
            /// regular conversions
            FAST: u1,
            /// Analog watchdog fast mode
            /// select
            AWFSEL: u1,
            padding0: u1,
        }), base_address + 0x180);

        /// address: 0x40016184
        /// control register 2
        pub const DFSDM_FLT1CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected end of conversion interrupt
            /// enable
            JEOCIE: u1,
            /// Regular end of conversion interrupt
            /// enable
            REOCIE: u1,
            /// Injected data overrun interrupt
            /// enable
            JOVRIE: u1,
            /// Regular data overrun interrupt
            /// enable
            ROVRIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Short-circuit detector interrupt
            /// enable
            SCDIE: u1,
            /// Clock absence interrupt
            /// enable
            CKABIE: u1,
            reserved0: u1,
            /// Extremes detector channel
            /// selection
            EXCH: u8,
            /// Analog watchdog channel
            /// selection
            AWDCH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x184);

        /// address: 0x40016188
        /// interrupt and status register
        pub const DFSDM_FLT1ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of injected conversion
            /// flag
            JEOCF: u1,
            /// End of regular conversion
            /// flag
            REOCF: u1,
            /// Injected conversion overrun
            /// flag
            JOVRF: u1,
            /// Regular conversion overrun
            /// flag
            ROVRF: u1,
            /// Analog watchdog
            AWDF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Injected conversion in progress
            /// status
            JCIP: u1,
            /// Regular conversion in progress
            /// status
            RCIP: u1,
            reserved8: u1,
            /// Clock absence flag
            CKABF: u8,
            /// short-circuit detector
            /// flag
            SCDF: u8,
        }), base_address + 0x188);

        /// address: 0x4001618c
        /// interrupt flag clear register
        pub const DFSDM_FLT1ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Clear the injected conversion overrun
            /// flag
            CLRJOVRF: u1,
            /// Clear the regular conversion overrun
            /// flag
            CLRROVRF: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the clock absence
            /// flag
            CLRCKABF: u8,
            /// Clear the short-circuit detector
            /// flag
            CLRSCDF: u8,
        }), base_address + 0x18c);

        /// address: 0x40016190
        /// injected channel group selection
        /// register
        pub const DFSDM_FLT1CHGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel group
            /// selection
            JCHG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x190);

        /// address: 0x40016194
        /// filter control register
        pub const DFSDM_FLT1FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integrator oversampling ratio (averaging
            /// length)
            IOSR: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Sinc filter oversampling ratio
            /// (decimation rate)
            FOSR: u10,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Sinc filter order
            FORD: u3,
        }), base_address + 0x194);

        /// address: 0x40016198
        /// data register for injected
        /// group
        pub const DFSDM_FLT1JDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel most recently
            /// converted
            JDATACH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Injected group conversion
            /// data
            JDATA: u24,
        }), base_address + 0x198);

        /// address: 0x4001619c
        /// data register for the regular
        /// channel
        pub const DFSDM_FLT1RDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular channel most recently
            /// converted
            RDATACH: u3,
            reserved0: u1,
            /// Regular channel pending
            /// data
            RPEND: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Regular channel conversion
            /// data
            RDATA: u24,
        }), base_address + 0x19c);

        /// address: 0x400161a0
        /// analog watchdog high threshold
        /// register
        pub const DFSDM_FLT1AWHTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog high threshold event
            BKAWH: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog high
            /// threshold
            AWHT: u24,
        }), base_address + 0x1a0);

        /// address: 0x400161a4
        /// analog watchdog low threshold
        /// register
        pub const DFSDM_FLT1AWLTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog low threshold event
            BKAWL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog low
            /// threshold
            AWLT: u24,
        }), base_address + 0x1a4);

        /// address: 0x400161a8
        /// analog watchdog status
        /// register
        pub const DFSDM_FLT1AWSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog low threshold
            /// flag
            AWLTF: u8,
            /// Analog watchdog high threshold
            /// flag
            AWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1a8);

        /// address: 0x400161ac
        /// analog watchdog clear flag
        /// register
        pub const DFSDM_FLT1AWCFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the analog watchdog low threshold
            /// flag
            CLRAWLTF: u8,
            /// Clear the analog watchdog high threshold
            /// flag
            CLRAWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1ac);

        /// address: 0x400161b0
        /// Extremes detector maximum
        /// register
        pub const DFSDM_FLT1EXMAX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector maximum data
            /// channel
            EXMAXCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector maximum
            /// value
            EXMAX: u24,
        }), base_address + 0x1b0);

        /// address: 0x400161b4
        /// Extremes detector minimum
        /// register
        pub const DFSDM_FLT1EXMIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector minimum data
            /// channel
            EXMINCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// EXMIN
            EXMIN: u24,
        }), base_address + 0x1b4);

        /// address: 0x400161b8
        /// conversion timer register
        pub const DFSDM_FLT1CNVTIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 28-bit timer counting conversion time t
            /// = CNVCNT[27:0] / fDFSDM_CKIN
            CNVCNT: u28,
        }), base_address + 0x1b8);

        /// address: 0x40016200
        /// control register 1
        pub const DFSDM_FLT2CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DFSDM enable
            DFEN: u1,
            /// Start a conversion of the injected group
            /// of channels
            JSWSTART: u1,
            reserved0: u1,
            /// Launch an injected conversion
            /// synchronously with the DFSDM0 JSWSTART
            /// trigger
            JSYNC: u1,
            /// Scanning conversion mode for injected
            /// conversions
            JSCAN: u1,
            /// DMA channel enabled to read data for the
            /// injected channel group
            JDMAEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger signal selection for launching
            /// injected conversions
            JEXTSEL: u3,
            reserved3: u1,
            reserved4: u1,
            /// Trigger enable and trigger edge
            /// selection for injected conversions
            JEXTEN: u2,
            reserved5: u1,
            reserved6: u1,
            /// Software start of a conversion on the
            /// regular channel
            RSWSTART: u1,
            /// Continuous mode selection for regular
            /// conversions
            RCONT: u1,
            /// Launch regular conversion synchronously
            /// with DFSDM0
            RSYNC: u1,
            reserved7: u1,
            /// DMA channel enabled to read data for the
            /// regular conversion
            RDMAEN: u1,
            reserved8: u1,
            reserved9: u1,
            /// Regular channel selection
            RCH: u3,
            reserved10: u1,
            reserved11: u1,
            /// Fast conversion mode selection for
            /// regular conversions
            FAST: u1,
            /// Analog watchdog fast mode
            /// select
            AWFSEL: u1,
            padding0: u1,
        }), base_address + 0x200);

        /// address: 0x40016204
        /// control register 2
        pub const DFSDM_FLT2CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected end of conversion interrupt
            /// enable
            JEOCIE: u1,
            /// Regular end of conversion interrupt
            /// enable
            REOCIE: u1,
            /// Injected data overrun interrupt
            /// enable
            JOVRIE: u1,
            /// Regular data overrun interrupt
            /// enable
            ROVRIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Short-circuit detector interrupt
            /// enable
            SCDIE: u1,
            /// Clock absence interrupt
            /// enable
            CKABIE: u1,
            reserved0: u1,
            /// Extremes detector channel
            /// selection
            EXCH: u8,
            /// Analog watchdog channel
            /// selection
            AWDCH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x204);

        /// address: 0x40016208
        /// interrupt and status register
        pub const DFSDM_FLT2ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of injected conversion
            /// flag
            JEOCF: u1,
            /// End of regular conversion
            /// flag
            REOCF: u1,
            /// Injected conversion overrun
            /// flag
            JOVRF: u1,
            /// Regular conversion overrun
            /// flag
            ROVRF: u1,
            /// Analog watchdog
            AWDF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Injected conversion in progress
            /// status
            JCIP: u1,
            /// Regular conversion in progress
            /// status
            RCIP: u1,
            reserved8: u1,
            /// Clock absence flag
            CKABF: u8,
            /// short-circuit detector
            /// flag
            SCDF: u8,
        }), base_address + 0x208);

        /// address: 0x4001620c
        /// interrupt flag clear register
        pub const DFSDM_FLT2ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Clear the injected conversion overrun
            /// flag
            CLRJOVRF: u1,
            /// Clear the regular conversion overrun
            /// flag
            CLRROVRF: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the clock absence
            /// flag
            CLRCKABF: u8,
            /// Clear the short-circuit detector
            /// flag
            CLRSCDF: u8,
        }), base_address + 0x20c);

        /// address: 0x40016210
        /// injected channel group selection
        /// register
        pub const DFSDM_FLT2JCHGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel group
            /// selection
            JCHG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x210);

        /// address: 0x40016214
        /// filter control register
        pub const DFSDM_FLT2FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integrator oversampling ratio (averaging
            /// length)
            IOSR: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Sinc filter oversampling ratio
            /// (decimation rate)
            FOSR: u10,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Sinc filter order
            FORD: u3,
        }), base_address + 0x214);

        /// address: 0x40016218
        /// data register for injected
        /// group
        pub const DFSDM_FLT2JDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel most recently
            /// converted
            JDATACH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Injected group conversion
            /// data
            JDATA: u24,
        }), base_address + 0x218);

        /// address: 0x4001621c
        /// data register for the regular
        /// channel
        pub const DFSDM_FLT2RDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular channel most recently
            /// converted
            RDATACH: u3,
            reserved0: u1,
            /// Regular channel pending
            /// data
            RPEND: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Regular channel conversion
            /// data
            RDATA: u24,
        }), base_address + 0x21c);

        /// address: 0x40016220
        /// analog watchdog high threshold
        /// register
        pub const DFSDM_FLT2AWHTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog high threshold event
            BKAWH: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog high
            /// threshold
            AWHT: u24,
        }), base_address + 0x220);

        /// address: 0x40016224
        /// analog watchdog low threshold
        /// register
        pub const DFSDM_FLT2AWLTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog low threshold event
            BKAWL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog low
            /// threshold
            AWLT: u24,
        }), base_address + 0x224);

        /// address: 0x40016228
        /// analog watchdog status
        /// register
        pub const DFSDM_FLT2AWSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog low threshold
            /// flag
            AWLTF: u8,
            /// Analog watchdog high threshold
            /// flag
            AWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x228);

        /// address: 0x4001622c
        /// analog watchdog clear flag
        /// register
        pub const DFSDM_FLT2AWCFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the analog watchdog low threshold
            /// flag
            CLRAWLTF: u8,
            /// Clear the analog watchdog high threshold
            /// flag
            CLRAWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x22c);

        /// address: 0x40016230
        /// Extremes detector maximum
        /// register
        pub const DFSDM_FLT2EXMAX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector maximum data
            /// channel
            EXMAXCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector maximum
            /// value
            EXMAX: u24,
        }), base_address + 0x230);

        /// address: 0x40016234
        /// Extremes detector minimum
        /// register
        pub const DFSDM_FLT2EXMIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector minimum data
            /// channel
            EXMINCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// EXMIN
            EXMIN: u24,
        }), base_address + 0x234);

        /// address: 0x40016238
        /// conversion timer register
        pub const DFSDM_FLT2CNVTIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 28-bit timer counting conversion time t
            /// = CNVCNT[27:0] / fDFSDM_CKIN
            CNVCNT: u28,
        }), base_address + 0x238);

        /// address: 0x40016280
        /// control register 1
        pub const DFSDM_FLT3CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// DFSDM enable
            DFEN: u1,
            /// Start a conversion of the injected group
            /// of channels
            JSWSTART: u1,
            reserved0: u1,
            /// Launch an injected conversion
            /// synchronously with the DFSDM0 JSWSTART
            /// trigger
            JSYNC: u1,
            /// Scanning conversion mode for injected
            /// conversions
            JSCAN: u1,
            /// DMA channel enabled to read data for the
            /// injected channel group
            JDMAEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger signal selection for launching
            /// injected conversions
            JEXTSEL: u3,
            reserved3: u1,
            reserved4: u1,
            /// Trigger enable and trigger edge
            /// selection for injected conversions
            JEXTEN: u2,
            reserved5: u1,
            reserved6: u1,
            /// Software start of a conversion on the
            /// regular channel
            RSWSTART: u1,
            /// Continuous mode selection for regular
            /// conversions
            RCONT: u1,
            /// Launch regular conversion synchronously
            /// with DFSDM0
            RSYNC: u1,
            reserved7: u1,
            /// DMA channel enabled to read data for the
            /// regular conversion
            RDMAEN: u1,
            reserved8: u1,
            reserved9: u1,
            /// Regular channel selection
            RCH: u3,
            reserved10: u1,
            reserved11: u1,
            /// Fast conversion mode selection for
            /// regular conversions
            FAST: u1,
            /// Analog watchdog fast mode
            /// select
            AWFSEL: u1,
            padding0: u1,
        }), base_address + 0x280);

        /// address: 0x40016284
        /// control register 2
        pub const DFSDM_FLT3CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected end of conversion interrupt
            /// enable
            JEOCIE: u1,
            /// Regular end of conversion interrupt
            /// enable
            REOCIE: u1,
            /// Injected data overrun interrupt
            /// enable
            JOVRIE: u1,
            /// Regular data overrun interrupt
            /// enable
            ROVRIE: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            /// Short-circuit detector interrupt
            /// enable
            SCDIE: u1,
            /// Clock absence interrupt
            /// enable
            CKABIE: u1,
            reserved0: u1,
            /// Extremes detector channel
            /// selection
            EXCH: u8,
            /// Analog watchdog channel
            /// selection
            AWDCH: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x284);

        /// address: 0x40016288
        /// interrupt and status register
        pub const DFSDM_FLT3ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// End of injected conversion
            /// flag
            JEOCF: u1,
            /// End of regular conversion
            /// flag
            REOCF: u1,
            /// Injected conversion overrun
            /// flag
            JOVRF: u1,
            /// Regular conversion overrun
            /// flag
            ROVRF: u1,
            /// Analog watchdog
            AWDF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Injected conversion in progress
            /// status
            JCIP: u1,
            /// Regular conversion in progress
            /// status
            RCIP: u1,
            reserved8: u1,
            /// Clock absence flag
            CKABF: u8,
            /// short-circuit detector
            /// flag
            SCDF: u8,
        }), base_address + 0x288);

        /// address: 0x4001628c
        /// interrupt flag clear register
        pub const DFSDM_FLT3ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Clear the injected conversion overrun
            /// flag
            CLRJOVRF: u1,
            /// Clear the regular conversion overrun
            /// flag
            CLRROVRF: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            /// Clear the clock absence
            /// flag
            CLRCKABF: u8,
            /// Clear the short-circuit detector
            /// flag
            CLRSCDF: u8,
        }), base_address + 0x28c);

        /// address: 0x40016290
        /// injected channel group selection
        /// register
        pub const DFSDM_FLT3JCHGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel group
            /// selection
            JCHG: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x290);

        /// address: 0x40016294
        /// filter control register
        pub const DFSDM_FLT3FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Integrator oversampling ratio (averaging
            /// length)
            IOSR: u8,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Sinc filter oversampling ratio
            /// (decimation rate)
            FOSR: u10,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// Sinc filter order
            FORD: u3,
        }), base_address + 0x294);

        /// address: 0x40016298
        /// data register for injected
        /// group
        pub const DFSDM_FLT3JDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Injected channel most recently
            /// converted
            JDATACH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Injected group conversion
            /// data
            JDATA: u24,
        }), base_address + 0x298);

        /// address: 0x4001629c
        /// data register for the regular
        /// channel
        pub const DFSDM_FLT3RDATAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Regular channel most recently
            /// converted
            RDATACH: u3,
            reserved0: u1,
            /// Regular channel pending
            /// data
            RPEND: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Regular channel conversion
            /// data
            RDATA: u24,
        }), base_address + 0x29c);

        /// address: 0x400162a0
        /// analog watchdog high threshold
        /// register
        pub const DFSDM_FLT3AWHTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog high threshold event
            BKAWH: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog high
            /// threshold
            AWHT: u24,
        }), base_address + 0x2a0);

        /// address: 0x400162a4
        /// analog watchdog low threshold
        /// register
        pub const DFSDM_FLT3AWLTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Break signal assignment to analog
            /// watchdog low threshold event
            BKAWL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog low
            /// threshold
            AWLT: u24,
        }), base_address + 0x2a4);

        /// address: 0x400162a8
        /// analog watchdog status
        /// register
        pub const DFSDM_FLT3AWSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog low threshold
            /// flag
            AWLTF: u8,
            /// Analog watchdog high threshold
            /// flag
            AWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2a8);

        /// address: 0x400162ac
        /// analog watchdog clear flag
        /// register
        pub const DFSDM_FLT3AWCFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear the analog watchdog low threshold
            /// flag
            CLRAWLTF: u8,
            /// Clear the analog watchdog high threshold
            /// flag
            CLRAWHTF: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2ac);

        /// address: 0x400162b0
        /// Extremes detector maximum
        /// register
        pub const DFSDM_FLT3EXMAX = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector maximum data
            /// channel
            EXMAXCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extremes detector maximum
            /// value
            EXMAX: u24,
        }), base_address + 0x2b0);

        /// address: 0x400162b4
        /// Extremes detector minimum
        /// register
        pub const DFSDM_FLT3EXMIN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Extremes detector minimum data
            /// channel
            EXMINCH: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// EXMIN
            EXMIN: u24,
        }), base_address + 0x2b4);

        /// address: 0x400162b8
        /// conversion timer register
        pub const DFSDM_FLT3CNVTIMR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 28-bit timer counting conversion time t
            /// = CNVCNT[27:0] / fDFSDM_CKIN
            CNVCNT: u28,
        }), base_address + 0x2b8);
    };

    /// QuadSPI interface
    pub const QUADSPI = struct {
        pub const base_address = 0xa0001000;

        /// address: 0xa0001000
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enable
            EN: u1,
            /// Abort request
            ABORT: u1,
            /// DMA enable
            DMAEN: u1,
            /// Timeout counter enable
            TCEN: u1,
            /// Sample shift
            SSHIFT: u1,
            reserved0: u1,
            /// Dual-flash mode
            DFM: u1,
            /// FLASH memory selection
            FSEL: u1,
            /// IFO threshold level
            FTHRES: u5,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// FIFO threshold interrupt
            /// enable
            FTIE: u1,
            /// Status match interrupt
            /// enable
            SMIE: u1,
            /// TimeOut interrupt enable
            TOIE: u1,
            reserved4: u1,
            /// Automatic poll mode stop
            APMS: u1,
            /// Polling match mode
            PMM: u1,
            /// Clock prescaler
            PRESCALER: u8,
        }), base_address + 0x0);

        /// address: 0xa0001004
        /// device configuration register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Mode 0 / mode 3
            CKMODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Chip select high time
            CSHT: u3,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            /// FLASH memory size
            FSIZE: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x4);

        /// address: 0xa0001008
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transfer error flag
            TEF: u1,
            /// Transfer complete flag
            TCF: u1,
            /// FIFO threshold flag
            FTF: u1,
            /// Status match flag
            SMF: u1,
            /// Timeout flag
            TOF: u1,
            /// Busy
            BUSY: u1,
            reserved0: u1,
            reserved1: u1,
            /// FIFO level
            FLEVEL: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0xa000100c
        /// flag clear register
        pub const FCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clear transfer error flag
            CTEF: u1,
            /// Clear transfer complete
            /// flag
            CTCF: u1,
            reserved0: u1,
            /// Clear status match flag
            CSMF: u1,
            /// Clear timeout flag
            CTOF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0xc);

        /// address: 0xa0001010
        /// data length register
        pub const DLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data length
            DL: u32,
        }), base_address + 0x10);

        /// address: 0xa0001014
        /// communication configuration
        /// register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Instruction
            INSTRUCTION: u8,
            /// Instruction mode
            IMODE: u2,
            /// Address mode
            ADMODE: u2,
            /// Address size
            ADSIZE: u2,
            /// Alternate bytes mode
            ABMODE: u2,
            /// Alternate bytes size
            ABSIZE: u2,
            /// Number of dummy cycles
            DCYC: u5,
            reserved0: u1,
            /// Data mode
            DMODE: u2,
            /// Functional mode
            FMODE: u2,
            /// Send instruction only once
            /// mode
            SIOO: u1,
            reserved1: u1,
            /// DDR hold half cycle
            DHHC: u1,
            /// Double data rate mode
            DDRM: u1,
        }), base_address + 0x14);

        /// address: 0xa0001018
        /// address register
        pub const AR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Address
            ADDRESS: u32,
        }), base_address + 0x18);

        /// address: 0xa000101c
        /// ABR
        pub const ABR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ALTERNATE
            ALTERNATE: u32,
        }), base_address + 0x1c);

        /// address: 0xa0001020
        /// data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data
            DATA: u32,
        }), base_address + 0x20);

        /// address: 0xa0001024
        /// polling status mask register
        pub const PSMKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status mask
            MASK: u32,
        }), base_address + 0x24);

        /// address: 0xa0001028
        /// polling status match register
        pub const PSMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Status match
            MATCH: u32,
        }), base_address + 0x28);

        /// address: 0xa000102c
        /// polling interval register
        pub const PIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Polling interval
            INTERVAL: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x2c);

        /// address: 0xa0001030
        /// low-power timeout register
        pub const LPTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timeout period
            TIMEOUT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x30);
    };

    /// MCU debug component
    pub const DBGMCU = struct {
        pub const base_address = 0xe0042000;

        /// address: 0xe0042000
        /// DBGMCU_IDCODE
        pub const IDCODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device identifier
            DEV_ID: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Revision identifie
            REV_ID: u16,
        }), base_address + 0x0);

        /// address: 0xe0042004
        /// Debug MCU configuration
        /// register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Debug Sleep mode
            DBG_SLEEP: u1,
            /// Debug Stop mode
            DBG_STOP: u1,
            /// Debug Standby mode
            DBG_STANDBY: u1,
            reserved0: u1,
            reserved1: u1,
            /// Trace pin assignment
            /// control
            TRACE_IOEN: u1,
            /// Trace pin assignment
            /// control
            TRACE_MODE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0xe0042008
        /// Debug MCU APB1 freeze
        /// register1
        pub const APB1FZR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// TIM2 counter stopped when core is
            /// halted
            DBG_TIM2_STOP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// TIM6 counter stopped when core is
            /// halted
            DBG_TIM6_STOP: u1,
            /// TIM7 counter stopped when core is
            /// halted
            DBG_TIM7_STOP: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// RTC counter stopped when core is
            /// halted
            DBG_RTC_STOP: u1,
            /// Window watchdog counter stopped when
            /// core is halted
            DBG_WWDG_STOP: u1,
            /// Independent watchdog counter stopped
            /// when core is halted
            DBG_IWDG_STOP: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// I2C1 SMBUS timeout counter stopped when
            /// core is halted
            DBG_I2C1_STOP: u1,
            /// I2C2 SMBUS timeout counter stopped when
            /// core is halted
            DBG_I2C2_STOP: u1,
            /// I2C3 SMBUS timeout counter stopped when
            /// core is halted
            DBG_I2C3_STOP: u1,
            reserved15: u1,
            /// bxCAN stopped when core is
            /// halted
            DBG_CAN_STOP: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// LPTIM1 counter stopped when core is
            /// halted
            DBG_LPTIM1_STOP: u1,
        }), base_address + 0x8);

        /// address: 0xe004200c
        /// Debug MCU APB1 freeze register
        /// 2
        pub const APB1FZR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// LPTIM2 counter stopped when core is
            /// halted
            DBG_LPTIM2_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0xc);

        /// address: 0xe0042010
        /// Debug MCU APB2 freeze register
        pub const APB2FZR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            /// TIM1 counter stopped when core is
            /// halted
            DBG_TIM1_STOP: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// TIM15 counter stopped when core is
            /// halted
            DBG_TIM15_STOP: u1,
            /// TIM16 counter stopped when core is
            /// halted
            DBG_TIM16_STOP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x10);
    };

    /// Floting point unit
    pub const FPU = struct {
        pub const base_address = 0xe000ef34;

        /// address: 0xe000ef34
        /// Floating-point context control
        /// register
        pub const FPCCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSPACT
            LSPACT: u1,
            /// USER
            USER: u1,
            reserved0: u1,
            /// THREAD
            THREAD: u1,
            /// HFRDY
            HFRDY: u1,
            /// MMRDY
            MMRDY: u1,
            /// BFRDY
            BFRDY: u1,
            reserved1: u1,
            /// MONRDY
            MONRDY: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            /// LSPEN
            LSPEN: u1,
            /// ASPEN
            ASPEN: u1,
        }), base_address + 0x0);

        /// address: 0xe000ef38
        /// Floating-point context address
        /// register
        pub const FPCAR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Location of unpopulated
            /// floating-point
            ADDRESS: u29,
        }), base_address + 0x4);

        /// address: 0xe000ef3c
        /// Floating-point status control
        /// register
        pub const FPSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Invalid operation cumulative exception
            /// bit
            IOC: u1,
            /// Division by zero cumulative exception
            /// bit.
            DZC: u1,
            /// Overflow cumulative exception
            /// bit
            OFC: u1,
            /// Underflow cumulative exception
            /// bit
            UFC: u1,
            /// Inexact cumulative exception
            /// bit
            IXC: u1,
            reserved0: u1,
            reserved1: u1,
            /// Input denormal cumulative exception
            /// bit.
            IDC: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Rounding Mode control
            /// field
            RMode: u2,
            /// Flush-to-zero mode control
            /// bit:
            FZ: u1,
            /// Default NaN mode control
            /// bit
            DN: u1,
            /// Alternative half-precision control
            /// bit
            AHP: u1,
            reserved16: u1,
            /// Overflow condition code
            /// flag
            V: u1,
            /// Carry condition code flag
            C: u1,
            /// Zero condition code flag
            Z: u1,
            /// Negative condition code
            /// flag
            N: u1,
        }), base_address + 0x8);
    };

    /// Memory protection unit
    pub const MPU = struct {
        pub const base_address = 0xe000ed90;

        /// address: 0xe000ed90
        /// MPU type register
        pub const MPU_TYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Separate flag
            SEPARATE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Number of MPU data regions
            DREGION: u8,
            /// Number of MPU instruction
            /// regions
            IREGION: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0xe000ed94
        /// MPU control register
        pub const MPU_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enables the MPU
            ENABLE: u1,
            /// Enables the operation of MPU during hard
            /// fault
            HFNMIENA: u1,
            /// Enable priviliged software access to
            /// default memory map
            PRIVDEFENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0xe000ed98
        /// MPU region number register
        pub const MPU_RNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPU region
            REGION: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0xe000ed9c
        /// MPU region base address
        /// register
        pub const MPU_RBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPU region field
            REGION: u4,
            /// MPU region number valid
            VALID: u1,
            /// Region base address field
            ADDR: u27,
        }), base_address + 0xc);

        /// address: 0xe000eda0
        /// MPU region attribute and size
        /// register
        pub const MPU_RASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region enable bit.
            ENABLE: u1,
            /// Size of the MPU protection
            /// region
            SIZE: u5,
            reserved0: u1,
            reserved1: u1,
            /// Subregion disable bits
            SRD: u8,
            /// memory attribute
            B: u1,
            /// memory attribute
            C: u1,
            /// Shareable memory attribute
            S: u1,
            /// memory attribute
            TEX: u3,
            reserved2: u1,
            reserved3: u1,
            /// Access permission
            AP: u3,
            reserved4: u1,
            /// Instruction access disable
            /// bit
            XN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);
    };

    /// SysTick timer
    pub const STK = struct {
        pub const base_address = 0xe000e010;
    };

    /// System control block
    pub const SCB = struct {
        pub const base_address = 0xe000ed00;

        /// address: 0xe000ed00
        /// CPUID base register
        pub const CPUID = @intToPtr(*volatile Mmio(32, packed struct {
            /// Revision number
            Revision: u4,
            /// Part number of the
            /// processor
            PartNo: u12,
            /// Reads as 0xF
            Constant: u4,
            /// Variant number
            Variant: u4,
            /// Implementer code
            Implementer: u8,
        }), base_address + 0x0);

        /// address: 0xe000ed04
        /// Interrupt control and state
        /// register
        pub const ICSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Active vector
            VECTACTIVE: u9,
            reserved0: u1,
            reserved1: u1,
            /// Return to base level
            RETTOBASE: u1,
            /// Pending vector
            VECTPENDING: u7,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Interrupt pending flag
            ISRPENDING: u1,
            reserved5: u1,
            reserved6: u1,
            /// SysTick exception clear-pending
            /// bit
            PENDSTCLR: u1,
            /// SysTick exception set-pending
            /// bit
            PENDSTSET: u1,
            /// PendSV clear-pending bit
            PENDSVCLR: u1,
            /// PendSV set-pending bit
            PENDSVSET: u1,
            reserved7: u1,
            reserved8: u1,
            /// NMI set-pending bit.
            NMIPENDSET: u1,
        }), base_address + 0x4);

        /// address: 0xe000ed08
        /// Vector table offset register
        pub const VTOR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Vector table base offset
            /// field
            TBLOFF: u21,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x8);

        /// address: 0xe000ed0c
        /// Application interrupt and reset control
        /// register
        pub const AIRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// VECTRESET
            VECTRESET: u1,
            /// VECTCLRACTIVE
            VECTCLRACTIVE: u1,
            /// SYSRESETREQ
            SYSRESETREQ: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// PRIGROUP
            PRIGROUP: u3,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// ENDIANESS
            ENDIANESS: u1,
            /// Register key
            VECTKEYSTAT: u16,
        }), base_address + 0xc);

        /// address: 0xe000ed10
        /// System control register
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// SLEEPONEXIT
            SLEEPONEXIT: u1,
            /// SLEEPDEEP
            SLEEPDEEP: u1,
            reserved1: u1,
            /// Send Event on Pending bit
            SEVEONPEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x10);

        /// address: 0xe000ed14
        /// Configuration and control
        /// register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Configures how the processor enters
            /// Thread mode
            NONBASETHRDENA: u1,
            /// USERSETMPEND
            USERSETMPEND: u1,
            reserved0: u1,
            /// UNALIGN_ TRP
            UNALIGN__TRP: u1,
            /// DIV_0_TRP
            DIV_0_TRP: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BFHFNMIGN
            BFHFNMIGN: u1,
            /// STKALIGN
            STKALIGN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x14);

        /// address: 0xe000ed18
        /// System handler priority
        /// registers
        pub const SHPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Priority of system handler
            /// 4
            PRI_4: u8,
            /// Priority of system handler
            /// 5
            PRI_5: u8,
            /// Priority of system handler
            /// 6
            PRI_6: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0xe000ed1c
        /// System handler priority
        /// registers
        pub const SHPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Priority of system handler
            /// 11
            PRI_11: u8,
        }), base_address + 0x1c);

        /// address: 0xe000ed20
        /// System handler priority
        /// registers
        pub const SHPR3 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Priority of system handler
            /// 14
            PRI_14: u8,
            /// Priority of system handler
            /// 15
            PRI_15: u8,
        }), base_address + 0x20);

        /// address: 0xe000ed24
        /// System handler control and state
        /// register
        pub const SHCSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory management fault exception active
            /// bit
            MEMFAULTACT: u1,
            /// Bus fault exception active
            /// bit
            BUSFAULTACT: u1,
            reserved0: u1,
            /// Usage fault exception active
            /// bit
            USGFAULTACT: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// SVC call active bit
            SVCALLACT: u1,
            /// Debug monitor active bit
            MONITORACT: u1,
            reserved4: u1,
            /// PendSV exception active
            /// bit
            PENDSVACT: u1,
            /// SysTick exception active
            /// bit
            SYSTICKACT: u1,
            /// Usage fault exception pending
            /// bit
            USGFAULTPENDED: u1,
            /// Memory management fault exception
            /// pending bit
            MEMFAULTPENDED: u1,
            /// Bus fault exception pending
            /// bit
            BUSFAULTPENDED: u1,
            /// SVC call pending bit
            SVCALLPENDED: u1,
            /// Memory management fault enable
            /// bit
            MEMFAULTENA: u1,
            /// Bus fault enable bit
            BUSFAULTENA: u1,
            /// Usage fault enable bit
            USGFAULTENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x24);

        /// address: 0xe000ed28
        /// Configurable fault status
        /// register
        pub const CFSR_UFSR_BFSR_MMFSR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Instruction access violation
            /// flag
            IACCVIOL: u1,
            reserved1: u1,
            /// Memory manager fault on unstacking for a
            /// return from exception
            MUNSTKERR: u1,
            /// Memory manager fault on stacking for
            /// exception entry.
            MSTKERR: u1,
            /// MLSPERR
            MLSPERR: u1,
            reserved2: u1,
            /// Memory Management Fault Address Register
            /// (MMAR) valid flag
            MMARVALID: u1,
            /// Instruction bus error
            IBUSERR: u1,
            /// Precise data bus error
            PRECISERR: u1,
            /// Imprecise data bus error
            IMPRECISERR: u1,
            /// Bus fault on unstacking for a return
            /// from exception
            UNSTKERR: u1,
            /// Bus fault on stacking for exception
            /// entry
            STKERR: u1,
            /// Bus fault on floating-point lazy state
            /// preservation
            LSPERR: u1,
            reserved3: u1,
            /// Bus Fault Address Register (BFAR) valid
            /// flag
            BFARVALID: u1,
            /// Undefined instruction usage
            /// fault
            UNDEFINSTR: u1,
            /// Invalid state usage fault
            INVSTATE: u1,
            /// Invalid PC load usage
            /// fault
            INVPC: u1,
            /// No coprocessor usage
            /// fault.
            NOCP: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Unaligned access usage
            /// fault
            UNALIGNED: u1,
            /// Divide by zero usage fault
            DIVBYZERO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x28);

        /// address: 0xe000ed2c
        /// Hard fault status register
        pub const HFSR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Vector table hard fault
            VECTTBL: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            reserved24: u1,
            reserved25: u1,
            reserved26: u1,
            reserved27: u1,
            reserved28: u1,
            /// Forced hard fault
            FORCED: u1,
            /// Reserved for Debug use
            DEBUG_VT: u1,
        }), base_address + 0x2c);

        /// address: 0xe000ed34
        /// Memory management fault address
        /// register
        pub const MMFAR = @intToPtr(*volatile u32, base_address + 0x34);

        /// address: 0xe000ed38
        /// Bus fault address register
        pub const BFAR = @intToPtr(*volatile u32, base_address + 0x38);

        /// address: 0xe000ed3c
        /// Auxiliary fault status
        /// register
        pub const AFSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Implementation defined
            IMPDEF: u32,
        }), base_address + 0x3c);
    };

    /// Nested vectored interrupt
    /// controller
    pub const NVIC_STIR = struct {
        pub const base_address = 0xe000ef00;

        /// address: 0xe000ef00
        /// Software trigger interrupt
        /// register
        pub const STIR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software generated interrupt
            /// ID
            INTID: u9,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x0);
    };

    /// Floating point unit CPACR
    pub const FPU_CPACR = struct {
        pub const base_address = 0xe000ed88;

        /// address: 0xe000ed88
        /// Coprocessor access control
        /// register
        pub const CPACR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// CP
            CP: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);
    };

    /// System control block ACTLR
    pub const SCB_ACTRL = struct {
        pub const base_address = 0xe000e008;

        /// address: 0xe000e008
        /// Auxiliary control register
        pub const ACTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// DISMCYCINT
            DISMCYCINT: u1,
            /// DISDEFWBUF
            DISDEFWBUF: u1,
            /// DISFOLD
            DISFOLD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// DISFPCA
            DISFPCA: u1,
            /// DISOOFP
            DISOOFP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

pub const InterruptVector = extern union {
    C: *const fn () callconv(.C) void,
    Naked: *const fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
